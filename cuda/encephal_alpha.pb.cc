// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encephal_alpha.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "encephal_alpha.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace encephal_alpha {

namespace {

const ::google::protobuf::Descriptor* DataType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataType_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DataType_NumericType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PerceptronLayerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PerceptronLayerData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConvolutionalLayerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConvolutionalLayerData_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ConvolutionalLayerData_ZeroPaddingType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* DropoutLayerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DropoutLayerData_reflection_ = NULL;
const ::google::protobuf::Descriptor* FullConnexionLayerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FullConnexionLayerData_reflection_ = NULL;
const ::google::protobuf::Descriptor* PipeNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PipeNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* PipeNode_PipeNodeData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PipeNode_PipeNodeData_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PipeNode_PipeNodeType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Connection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Connection_reflection_ = NULL;
const ::google::protobuf::Descriptor* Socket_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Socket_reflection_ = NULL;
const ::google::protobuf::Descriptor* SchedulerNodeLayer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SchedulerNodeLayer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Graph_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Graph_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataArray_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataArray_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrainingDataEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrainingDataEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TestingDataEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TestingDataEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataEntry_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DataEntry_DataEntryType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ActivationFunction_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_encephal_5falpha_2eproto() {
  protobuf_AddDesc_encephal_5falpha_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "encephal_alpha.proto");
  GOOGLE_CHECK(file != NULL);
  DataType_descriptor_ = file->message_type(0);
  static const int DataType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataType, dimensions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataType, type_),
  };
  DataType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataType_descriptor_,
      DataType::default_instance_,
      DataType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataType));
  DataType_NumericType_descriptor_ = DataType_descriptor_->enum_type(0);
  PerceptronLayerData_descriptor_ = file->message_type(1);
  static const int PerceptronLayerData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerceptronLayerData, activation_function_),
  };
  PerceptronLayerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PerceptronLayerData_descriptor_,
      PerceptronLayerData::default_instance_,
      PerceptronLayerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerceptronLayerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerceptronLayerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PerceptronLayerData));
  ConvolutionalLayerData_descriptor_ = file->message_type(2);
  static const int ConvolutionalLayerData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalLayerData, zero_padding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalLayerData, kernel_shape_),
  };
  ConvolutionalLayerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConvolutionalLayerData_descriptor_,
      ConvolutionalLayerData::default_instance_,
      ConvolutionalLayerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalLayerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalLayerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConvolutionalLayerData));
  ConvolutionalLayerData_ZeroPaddingType_descriptor_ = ConvolutionalLayerData_descriptor_->enum_type(0);
  DropoutLayerData_descriptor_ = file->message_type(3);
  static const int DropoutLayerData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropoutLayerData, p_),
  };
  DropoutLayerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DropoutLayerData_descriptor_,
      DropoutLayerData::default_instance_,
      DropoutLayerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropoutLayerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropoutLayerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DropoutLayerData));
  FullConnexionLayerData_descriptor_ = file->message_type(4);
  static const int FullConnexionLayerData_offsets_[1] = {
  };
  FullConnexionLayerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FullConnexionLayerData_descriptor_,
      FullConnexionLayerData::default_instance_,
      FullConnexionLayerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FullConnexionLayerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FullConnexionLayerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FullConnexionLayerData));
  PipeNode_descriptor_ = file->message_type(5);
  static const int PipeNode_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, input_datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, output_datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, input_socket_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, output_socket_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, node_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, data_),
  };
  PipeNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PipeNode_descriptor_,
      PipeNode::default_instance_,
      PipeNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PipeNode));
  PipeNode_PipeNodeData_descriptor_ = PipeNode_descriptor_->nested_type(0);
  static const int PipeNode_PipeNodeData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, full_connexion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, dropout_layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, perceptron_layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, convolutional_layer_),
  };
  PipeNode_PipeNodeData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PipeNode_PipeNodeData_descriptor_,
      PipeNode_PipeNodeData::default_instance_,
      PipeNode_PipeNodeData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PipeNode_PipeNodeData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PipeNode_PipeNodeData));
  PipeNode_PipeNodeType_descriptor_ = PipeNode_descriptor_->enum_type(0);
  Connection_descriptor_ = file->message_type(6);
  static const int Connection_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connection, socket_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connection, node_index_),
  };
  Connection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Connection_descriptor_,
      Connection::default_instance_,
      Connection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Connection));
  Socket_descriptor_ = file->message_type(7);
  static const int Socket_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, datatype_),
  };
  Socket_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Socket_descriptor_,
      Socket::default_instance_,
      Socket_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Socket));
  SchedulerNodeLayer_descriptor_ = file->message_type(8);
  static const int SchedulerNodeLayer_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SchedulerNodeLayer, nodes_),
  };
  SchedulerNodeLayer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SchedulerNodeLayer_descriptor_,
      SchedulerNodeLayer::default_instance_,
      SchedulerNodeLayer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SchedulerNodeLayer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SchedulerNodeLayer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SchedulerNodeLayer));
  Graph_descriptor_ = file->message_type(9);
  static const int Graph_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, node_layers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, sockets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, entry_socket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, exit_socket_),
  };
  Graph_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Graph_descriptor_,
      Graph::default_instance_,
      Graph_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graph, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Graph));
  DataArray_descriptor_ = file->message_type(10);
  static const int DataArray_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, float_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, uint32_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, uint64_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, bool_vector_),
  };
  DataArray_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataArray_descriptor_,
      DataArray::default_instance_,
      DataArray_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataArray, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataArray));
  TrainingDataEntry_descriptor_ = file->message_type(11);
  static const int TrainingDataEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, input_datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, output_datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, label_),
  };
  TrainingDataEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TrainingDataEntry_descriptor_,
      TrainingDataEntry::default_instance_,
      TrainingDataEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainingDataEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TrainingDataEntry));
  TestingDataEntry_descriptor_ = file->message_type(12);
  static const int TestingDataEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestingDataEntry, input_datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestingDataEntry, entries_),
  };
  TestingDataEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TestingDataEntry_descriptor_,
      TestingDataEntry::default_instance_,
      TestingDataEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestingDataEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestingDataEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TestingDataEntry));
  DataEntry_descriptor_ = file->message_type(13);
  static const int DataEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEntry, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEntry, traindataentry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEntry, testdataentry_),
  };
  DataEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataEntry_descriptor_,
      DataEntry::default_instance_,
      DataEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataEntry));
  DataEntry_DataEntryType_descriptor_ = DataEntry_descriptor_->enum_type(0);
  ActivationFunction_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_encephal_5falpha_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataType_descriptor_, &DataType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PerceptronLayerData_descriptor_, &PerceptronLayerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConvolutionalLayerData_descriptor_, &ConvolutionalLayerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DropoutLayerData_descriptor_, &DropoutLayerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FullConnexionLayerData_descriptor_, &FullConnexionLayerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PipeNode_descriptor_, &PipeNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PipeNode_PipeNodeData_descriptor_, &PipeNode_PipeNodeData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Connection_descriptor_, &Connection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Socket_descriptor_, &Socket::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SchedulerNodeLayer_descriptor_, &SchedulerNodeLayer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Graph_descriptor_, &Graph::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataArray_descriptor_, &DataArray::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TrainingDataEntry_descriptor_, &TrainingDataEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TestingDataEntry_descriptor_, &TestingDataEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataEntry_descriptor_, &DataEntry::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_encephal_5falpha_2eproto() {
  delete DataType::default_instance_;
  delete DataType_reflection_;
  delete PerceptronLayerData::default_instance_;
  delete PerceptronLayerData_reflection_;
  delete ConvolutionalLayerData::default_instance_;
  delete ConvolutionalLayerData_reflection_;
  delete DropoutLayerData::default_instance_;
  delete DropoutLayerData_reflection_;
  delete FullConnexionLayerData::default_instance_;
  delete FullConnexionLayerData_reflection_;
  delete PipeNode::default_instance_;
  delete PipeNode_reflection_;
  delete PipeNode_PipeNodeData::default_instance_;
  delete PipeNode_PipeNodeData_reflection_;
  delete Connection::default_instance_;
  delete Connection_reflection_;
  delete Socket::default_instance_;
  delete Socket_reflection_;
  delete SchedulerNodeLayer::default_instance_;
  delete SchedulerNodeLayer_reflection_;
  delete Graph::default_instance_;
  delete Graph_reflection_;
  delete DataArray::default_instance_;
  delete DataArray_reflection_;
  delete TrainingDataEntry::default_instance_;
  delete TrainingDataEntry_reflection_;
  delete TestingDataEntry::default_instance_;
  delete TestingDataEntry_reflection_;
  delete DataEntry::default_instance_;
  delete DataEntry_reflection_;
}

void protobuf_AddDesc_encephal_5falpha_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024encephal_alpha.proto\022\016encephal_alpha\"\214"
    "\001\n\010DataType\022\022\n\ndimensions\030\001 \003(\r\0222\n\004type\030"
    "\002 \002(\0162$.encephal_alpha.DataType.NumericT"
    "ype\"8\n\013NumericType\022\t\n\005FLOAT\020\001\022\t\n\005INT32\020\002"
    "\022\t\n\005INT64\020\003\022\010\n\004BOOL\020\004\"V\n\023PerceptronLayer"
    "Data\022\?\n\023activation_function\030\001 \002(\0162\".ence"
    "phal_alpha.ActivationFunction\"\256\001\n\026Convol"
    "utionalLayerData\022L\n\014zero_padding\030\001 \002(\01626"
    ".encephal_alpha.ConvolutionalLayerData.Z"
    "eroPaddingType\022\024\n\014kernel_shape\030\002 \003(\r\"0\n\017"
    "ZeroPaddingType\022\t\n\005VALID\020\001\022\010\n\004SAME\020\002\022\010\n\004"
    "FULL\020\003\"\035\n\020DropoutLayerData\022\t\n\001p\030\001 \002(\002\"\030\n"
    "\026FullConnexionLayerData\"\232\005\n\010PipeNode\022\r\n\005"
    "index\030\001 \002(\r\0220\n\016input_datatype\030\002 \002(\0132\030.en"
    "cephal_alpha.DataType\0221\n\017output_datatype"
    "\030\003 \002(\0132\030.encephal_alpha.DataType\022\032\n\022inpu"
    "t_socket_index\030\004 \002(\r\022\033\n\023output_socket_in"
    "dex\030\005 \002(\r\0228\n\tnode_type\030\006 \002(\0162%.encephal_"
    "alpha.PipeNode.PipeNodeType\0223\n\004data\030\007 \002("
    "\0132%.encephal_alpha.PipeNode.PipeNodeData"
    "\032\213\002\n\014PipeNodeData\022>\n\016full_connexion\030\001 \001("
    "\0132&.encephal_alpha.FullConnexionLayerDat"
    "a\0227\n\rdropout_layer\030\002 \001(\0132 .encephal_alph"
    "a.DropoutLayerData\022=\n\020perceptron_layer\030\003"
    " \001(\0132#.encephal_alpha.PerceptronLayerDat"
    "a\022C\n\023convolutional_layer\030\004 \001(\0132&.encepha"
    "l_alpha.ConvolutionalLayerData\"d\n\014PipeNo"
    "deType\022\022\n\016FULL_CONNEXION\020\001\022\021\n\rDROPOUT_LA"
    "YER\020\002\022\024\n\020PERCEPTRON_LAYER\020\003\022\027\n\023CONVOLUTI"
    "ONAL_LAYER\020\004\"6\n\nConnection\022\024\n\014socket_ind"
    "ex\030\001 \002(\r\022\022\n\nnode_index\030\002 \002(\r\"C\n\006Socket\022\r"
    "\n\005index\030\001 \002(\r\022*\n\010datatype\030\002 \002(\0132\030.enceph"
    "al_alpha.DataType\"=\n\022SchedulerNodeLayer\022"
    "\'\n\005nodes\030\001 \003(\0132\030.encephal_alpha.PipeNode"
    "\"\224\001\n\005Graph\0227\n\013node_layers\030\001 \003(\0132\".enceph"
    "al_alpha.SchedulerNodeLayer\022\'\n\007sockets\030\002"
    " \003(\0132\026.encephal_alpha.Socket\022\024\n\014entry_so"
    "cket\030\003 \002(\r\022\023\n\013exit_socket\030\004 \002(\r\"d\n\tDataA"
    "rray\022\024\n\014float_vector\030\001 \003(\002\022\025\n\ruint32_vec"
    "tor\030\002 \003(\r\022\025\n\ruint64_vector\030\003 \003(\004\022\023\n\013bool"
    "_vector\030\004 \003(\010\"\314\001\n\021TrainingDataEntry\0220\n\016i"
    "nput_datatype\030\001 \002(\0132\030.encephal_alpha.Dat"
    "aType\0221\n\017output_datatype\030\002 \002(\0132\030.encepha"
    "l_alpha.DataType\022(\n\005input\030\003 \002(\0132\031.enceph"
    "al_alpha.DataArray\022(\n\005label\030\004 \002(\0132\031.ence"
    "phal_alpha.DataArray\"p\n\020TestingDataEntry"
    "\0220\n\016input_datatype\030\001 \002(\0132\030.encephal_alph"
    "a.DataType\022*\n\007entries\030\002 \002(\0132\031.encephal_a"
    "lpha.DataArray\"\334\001\n\tDataEntry\0225\n\004type\030\001 \002"
    "(\0162\'.encephal_alpha.DataEntry.DataEntryT"
    "ype\0229\n\016trainDataEntry\030\002 \001(\0132!.encephal_a"
    "lpha.TrainingDataEntry\0227\n\rtestDataEntry\030"
    "\003 \001(\0132 .encephal_alpha.TestingDataEntry\""
    "$\n\rDataEntryType\022\t\n\005TRAIN\020\001\022\010\n\004TEST\020\002*;\n"
    "\022ActivationFunction\022\013\n\007NOTHING\020\001\022\013\n\007SIGM"
    "OID\020\002\022\013\n\007SOFTMAX\020\003", 2218);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "encephal_alpha.proto", &protobuf_RegisterTypes);
  DataType::default_instance_ = new DataType();
  PerceptronLayerData::default_instance_ = new PerceptronLayerData();
  ConvolutionalLayerData::default_instance_ = new ConvolutionalLayerData();
  DropoutLayerData::default_instance_ = new DropoutLayerData();
  FullConnexionLayerData::default_instance_ = new FullConnexionLayerData();
  PipeNode::default_instance_ = new PipeNode();
  PipeNode_PipeNodeData::default_instance_ = new PipeNode_PipeNodeData();
  Connection::default_instance_ = new Connection();
  Socket::default_instance_ = new Socket();
  SchedulerNodeLayer::default_instance_ = new SchedulerNodeLayer();
  Graph::default_instance_ = new Graph();
  DataArray::default_instance_ = new DataArray();
  TrainingDataEntry::default_instance_ = new TrainingDataEntry();
  TestingDataEntry::default_instance_ = new TestingDataEntry();
  DataEntry::default_instance_ = new DataEntry();
  DataType::default_instance_->InitAsDefaultInstance();
  PerceptronLayerData::default_instance_->InitAsDefaultInstance();
  ConvolutionalLayerData::default_instance_->InitAsDefaultInstance();
  DropoutLayerData::default_instance_->InitAsDefaultInstance();
  FullConnexionLayerData::default_instance_->InitAsDefaultInstance();
  PipeNode::default_instance_->InitAsDefaultInstance();
  PipeNode_PipeNodeData::default_instance_->InitAsDefaultInstance();
  Connection::default_instance_->InitAsDefaultInstance();
  Socket::default_instance_->InitAsDefaultInstance();
  SchedulerNodeLayer::default_instance_->InitAsDefaultInstance();
  Graph::default_instance_->InitAsDefaultInstance();
  DataArray::default_instance_->InitAsDefaultInstance();
  TrainingDataEntry::default_instance_->InitAsDefaultInstance();
  TestingDataEntry::default_instance_->InitAsDefaultInstance();
  DataEntry::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_encephal_5falpha_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_encephal_5falpha_2eproto {
  StaticDescriptorInitializer_encephal_5falpha_2eproto() {
    protobuf_AddDesc_encephal_5falpha_2eproto();
  }
} static_descriptor_initializer_encephal_5falpha_2eproto_;
const ::google::protobuf::EnumDescriptor* ActivationFunction_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ActivationFunction_descriptor_;
}
bool ActivationFunction_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DataType_NumericType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataType_NumericType_descriptor_;
}
bool DataType_NumericType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DataType_NumericType DataType::FLOAT;
const DataType_NumericType DataType::INT32;
const DataType_NumericType DataType::INT64;
const DataType_NumericType DataType::BOOL;
const DataType_NumericType DataType::NumericType_MIN;
const DataType_NumericType DataType::NumericType_MAX;
const int DataType::NumericType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DataType::kDimensionsFieldNumber;
const int DataType::kTypeFieldNumber;
#endif  // !_MSC_VER

DataType::DataType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataType::InitAsDefaultInstance() {
}

DataType::DataType(const DataType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataType::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataType::~DataType() {
  SharedDtor();
}

void DataType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DataType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataType_descriptor_;
}

const DataType& DataType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

DataType* DataType::default_instance_ = NULL;

DataType* DataType::New() const {
  return new DataType;
}

void DataType::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    type_ = 1;
  }
  dimensions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 dimensions = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dimensions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_dimensions())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_dimensions())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_dimensions;
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .encephal_alpha.DataType.NumericType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::encephal_alpha::DataType_NumericType_IsValid(value)) {
            set_type(static_cast< ::encephal_alpha::DataType_NumericType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 dimensions = 1;
  for (int i = 0; i < this->dimensions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->dimensions(i), output);
  }

  // required .encephal_alpha.DataType.NumericType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 dimensions = 1;
  for (int i = 0; i < this->dimensions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->dimensions(i), target);
  }

  // required .encephal_alpha.DataType.NumericType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required .encephal_alpha.DataType.NumericType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  // repeated uint32 dimensions = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->dimensions_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->dimensions(i));
    }
    total_size += 1 * this->dimensions_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataType::MergeFrom(const DataType& from) {
  GOOGLE_CHECK_NE(&from, this);
  dimensions_.MergeFrom(from.dimensions_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataType::CopyFrom(const DataType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void DataType::Swap(DataType* other) {
  if (other != this) {
    dimensions_.Swap(&other->dimensions_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataType_descriptor_;
  metadata.reflection = DataType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PerceptronLayerData::kActivationFunctionFieldNumber;
#endif  // !_MSC_VER

PerceptronLayerData::PerceptronLayerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PerceptronLayerData::InitAsDefaultInstance() {
}

PerceptronLayerData::PerceptronLayerData(const PerceptronLayerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PerceptronLayerData::SharedCtor() {
  _cached_size_ = 0;
  activation_function_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerceptronLayerData::~PerceptronLayerData() {
  SharedDtor();
}

void PerceptronLayerData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PerceptronLayerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PerceptronLayerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PerceptronLayerData_descriptor_;
}

const PerceptronLayerData& PerceptronLayerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

PerceptronLayerData* PerceptronLayerData::default_instance_ = NULL;

PerceptronLayerData* PerceptronLayerData::New() const {
  return new PerceptronLayerData;
}

void PerceptronLayerData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    activation_function_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PerceptronLayerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .encephal_alpha.ActivationFunction activation_function = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::encephal_alpha::ActivationFunction_IsValid(value)) {
            set_activation_function(static_cast< ::encephal_alpha::ActivationFunction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PerceptronLayerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .encephal_alpha.ActivationFunction activation_function = 1;
  if (has_activation_function()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->activation_function(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PerceptronLayerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .encephal_alpha.ActivationFunction activation_function = 1;
  if (has_activation_function()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->activation_function(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PerceptronLayerData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .encephal_alpha.ActivationFunction activation_function = 1;
    if (has_activation_function()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->activation_function());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerceptronLayerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PerceptronLayerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PerceptronLayerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PerceptronLayerData::MergeFrom(const PerceptronLayerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activation_function()) {
      set_activation_function(from.activation_function());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PerceptronLayerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PerceptronLayerData::CopyFrom(const PerceptronLayerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerceptronLayerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PerceptronLayerData::Swap(PerceptronLayerData* other) {
  if (other != this) {
    std::swap(activation_function_, other->activation_function_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PerceptronLayerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PerceptronLayerData_descriptor_;
  metadata.reflection = PerceptronLayerData_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ConvolutionalLayerData_ZeroPaddingType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConvolutionalLayerData_ZeroPaddingType_descriptor_;
}
bool ConvolutionalLayerData_ZeroPaddingType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::VALID;
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::SAME;
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::FULL;
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::ZeroPaddingType_MIN;
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::ZeroPaddingType_MAX;
const int ConvolutionalLayerData::ZeroPaddingType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ConvolutionalLayerData::kZeroPaddingFieldNumber;
const int ConvolutionalLayerData::kKernelShapeFieldNumber;
#endif  // !_MSC_VER

ConvolutionalLayerData::ConvolutionalLayerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConvolutionalLayerData::InitAsDefaultInstance() {
}

ConvolutionalLayerData::ConvolutionalLayerData(const ConvolutionalLayerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConvolutionalLayerData::SharedCtor() {
  _cached_size_ = 0;
  zero_padding_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConvolutionalLayerData::~ConvolutionalLayerData() {
  SharedDtor();
}

void ConvolutionalLayerData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ConvolutionalLayerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConvolutionalLayerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConvolutionalLayerData_descriptor_;
}

const ConvolutionalLayerData& ConvolutionalLayerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

ConvolutionalLayerData* ConvolutionalLayerData::default_instance_ = NULL;

ConvolutionalLayerData* ConvolutionalLayerData::New() const {
  return new ConvolutionalLayerData;
}

void ConvolutionalLayerData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zero_padding_ = 1;
  }
  kernel_shape_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConvolutionalLayerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType_IsValid(value)) {
            set_zero_padding(static_cast< ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_kernel_shape;
        break;
      }

      // repeated uint32 kernel_shape = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kernel_shape:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_kernel_shape())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_kernel_shape())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_kernel_shape;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConvolutionalLayerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
  if (has_zero_padding()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->zero_padding(), output);
  }

  // repeated uint32 kernel_shape = 2;
  for (int i = 0; i < this->kernel_shape_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->kernel_shape(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConvolutionalLayerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
  if (has_zero_padding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->zero_padding(), target);
  }

  // repeated uint32 kernel_shape = 2;
  for (int i = 0; i < this->kernel_shape_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->kernel_shape(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConvolutionalLayerData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
    if (has_zero_padding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->zero_padding());
    }

  }
  // repeated uint32 kernel_shape = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->kernel_shape_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->kernel_shape(i));
    }
    total_size += 1 * this->kernel_shape_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConvolutionalLayerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConvolutionalLayerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConvolutionalLayerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConvolutionalLayerData::MergeFrom(const ConvolutionalLayerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  kernel_shape_.MergeFrom(from.kernel_shape_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zero_padding()) {
      set_zero_padding(from.zero_padding());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConvolutionalLayerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConvolutionalLayerData::CopyFrom(const ConvolutionalLayerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvolutionalLayerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ConvolutionalLayerData::Swap(ConvolutionalLayerData* other) {
  if (other != this) {
    std::swap(zero_padding_, other->zero_padding_);
    kernel_shape_.Swap(&other->kernel_shape_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConvolutionalLayerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConvolutionalLayerData_descriptor_;
  metadata.reflection = ConvolutionalLayerData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DropoutLayerData::kPFieldNumber;
#endif  // !_MSC_VER

DropoutLayerData::DropoutLayerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DropoutLayerData::InitAsDefaultInstance() {
}

DropoutLayerData::DropoutLayerData(const DropoutLayerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DropoutLayerData::SharedCtor() {
  _cached_size_ = 0;
  p_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropoutLayerData::~DropoutLayerData() {
  SharedDtor();
}

void DropoutLayerData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DropoutLayerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DropoutLayerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DropoutLayerData_descriptor_;
}

const DropoutLayerData& DropoutLayerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

DropoutLayerData* DropoutLayerData::default_instance_ = NULL;

DropoutLayerData* DropoutLayerData::New() const {
  return new DropoutLayerData;
}

void DropoutLayerData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    p_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DropoutLayerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float p = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DropoutLayerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float p = 1;
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->p(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DropoutLayerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float p = 1;
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->p(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DropoutLayerData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float p = 1;
    if (has_p()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropoutLayerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DropoutLayerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DropoutLayerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DropoutLayerData::MergeFrom(const DropoutLayerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p()) {
      set_p(from.p());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DropoutLayerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DropoutLayerData::CopyFrom(const DropoutLayerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropoutLayerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DropoutLayerData::Swap(DropoutLayerData* other) {
  if (other != this) {
    std::swap(p_, other->p_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DropoutLayerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DropoutLayerData_descriptor_;
  metadata.reflection = DropoutLayerData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

FullConnexionLayerData::FullConnexionLayerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FullConnexionLayerData::InitAsDefaultInstance() {
}

FullConnexionLayerData::FullConnexionLayerData(const FullConnexionLayerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FullConnexionLayerData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FullConnexionLayerData::~FullConnexionLayerData() {
  SharedDtor();
}

void FullConnexionLayerData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FullConnexionLayerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FullConnexionLayerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FullConnexionLayerData_descriptor_;
}

const FullConnexionLayerData& FullConnexionLayerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

FullConnexionLayerData* FullConnexionLayerData::default_instance_ = NULL;

FullConnexionLayerData* FullConnexionLayerData::New() const {
  return new FullConnexionLayerData;
}

void FullConnexionLayerData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FullConnexionLayerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void FullConnexionLayerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FullConnexionLayerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FullConnexionLayerData::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FullConnexionLayerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FullConnexionLayerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FullConnexionLayerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FullConnexionLayerData::MergeFrom(const FullConnexionLayerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FullConnexionLayerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FullConnexionLayerData::CopyFrom(const FullConnexionLayerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FullConnexionLayerData::IsInitialized() const {

  return true;
}

void FullConnexionLayerData::Swap(FullConnexionLayerData* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FullConnexionLayerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FullConnexionLayerData_descriptor_;
  metadata.reflection = FullConnexionLayerData_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* PipeNode_PipeNodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PipeNode_PipeNodeType_descriptor_;
}
bool PipeNode_PipeNodeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const PipeNode_PipeNodeType PipeNode::FULL_CONNEXION;
const PipeNode_PipeNodeType PipeNode::DROPOUT_LAYER;
const PipeNode_PipeNodeType PipeNode::PERCEPTRON_LAYER;
const PipeNode_PipeNodeType PipeNode::CONVOLUTIONAL_LAYER;
const PipeNode_PipeNodeType PipeNode::PipeNodeType_MIN;
const PipeNode_PipeNodeType PipeNode::PipeNodeType_MAX;
const int PipeNode::PipeNodeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int PipeNode_PipeNodeData::kFullConnexionFieldNumber;
const int PipeNode_PipeNodeData::kDropoutLayerFieldNumber;
const int PipeNode_PipeNodeData::kPerceptronLayerFieldNumber;
const int PipeNode_PipeNodeData::kConvolutionalLayerFieldNumber;
#endif  // !_MSC_VER

PipeNode_PipeNodeData::PipeNode_PipeNodeData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PipeNode_PipeNodeData::InitAsDefaultInstance() {
  full_connexion_ = const_cast< ::encephal_alpha::FullConnexionLayerData*>(&::encephal_alpha::FullConnexionLayerData::default_instance());
  dropout_layer_ = const_cast< ::encephal_alpha::DropoutLayerData*>(&::encephal_alpha::DropoutLayerData::default_instance());
  perceptron_layer_ = const_cast< ::encephal_alpha::PerceptronLayerData*>(&::encephal_alpha::PerceptronLayerData::default_instance());
  convolutional_layer_ = const_cast< ::encephal_alpha::ConvolutionalLayerData*>(&::encephal_alpha::ConvolutionalLayerData::default_instance());
}

PipeNode_PipeNodeData::PipeNode_PipeNodeData(const PipeNode_PipeNodeData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PipeNode_PipeNodeData::SharedCtor() {
  _cached_size_ = 0;
  full_connexion_ = NULL;
  dropout_layer_ = NULL;
  perceptron_layer_ = NULL;
  convolutional_layer_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PipeNode_PipeNodeData::~PipeNode_PipeNodeData() {
  SharedDtor();
}

void PipeNode_PipeNodeData::SharedDtor() {
  if (this != default_instance_) {
    delete full_connexion_;
    delete dropout_layer_;
    delete perceptron_layer_;
    delete convolutional_layer_;
  }
}

void PipeNode_PipeNodeData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PipeNode_PipeNodeData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PipeNode_PipeNodeData_descriptor_;
}

const PipeNode_PipeNodeData& PipeNode_PipeNodeData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

PipeNode_PipeNodeData* PipeNode_PipeNodeData::default_instance_ = NULL;

PipeNode_PipeNodeData* PipeNode_PipeNodeData::New() const {
  return new PipeNode_PipeNodeData;
}

void PipeNode_PipeNodeData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_full_connexion()) {
      if (full_connexion_ != NULL) full_connexion_->::encephal_alpha::FullConnexionLayerData::Clear();
    }
    if (has_dropout_layer()) {
      if (dropout_layer_ != NULL) dropout_layer_->::encephal_alpha::DropoutLayerData::Clear();
    }
    if (has_perceptron_layer()) {
      if (perceptron_layer_ != NULL) perceptron_layer_->::encephal_alpha::PerceptronLayerData::Clear();
    }
    if (has_convolutional_layer()) {
      if (convolutional_layer_ != NULL) convolutional_layer_->::encephal_alpha::ConvolutionalLayerData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PipeNode_PipeNodeData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_full_connexion()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dropout_layer;
        break;
      }

      // optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dropout_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dropout_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_perceptron_layer;
        break;
      }

      // optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_perceptron_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_perceptron_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_convolutional_layer;
        break;
      }

      // optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_convolutional_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_convolutional_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PipeNode_PipeNodeData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
  if (has_full_connexion()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->full_connexion(), output);
  }

  // optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
  if (has_dropout_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->dropout_layer(), output);
  }

  // optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
  if (has_perceptron_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->perceptron_layer(), output);
  }

  // optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
  if (has_convolutional_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->convolutional_layer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PipeNode_PipeNodeData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
  if (has_full_connexion()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->full_connexion(), target);
  }

  // optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
  if (has_dropout_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->dropout_layer(), target);
  }

  // optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
  if (has_perceptron_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->perceptron_layer(), target);
  }

  // optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
  if (has_convolutional_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->convolutional_layer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PipeNode_PipeNodeData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
    if (has_full_connexion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->full_connexion());
    }

    // optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
    if (has_dropout_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dropout_layer());
    }

    // optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
    if (has_perceptron_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->perceptron_layer());
    }

    // optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
    if (has_convolutional_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->convolutional_layer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PipeNode_PipeNodeData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PipeNode_PipeNodeData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PipeNode_PipeNodeData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PipeNode_PipeNodeData::MergeFrom(const PipeNode_PipeNodeData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_full_connexion()) {
      mutable_full_connexion()->::encephal_alpha::FullConnexionLayerData::MergeFrom(from.full_connexion());
    }
    if (from.has_dropout_layer()) {
      mutable_dropout_layer()->::encephal_alpha::DropoutLayerData::MergeFrom(from.dropout_layer());
    }
    if (from.has_perceptron_layer()) {
      mutable_perceptron_layer()->::encephal_alpha::PerceptronLayerData::MergeFrom(from.perceptron_layer());
    }
    if (from.has_convolutional_layer()) {
      mutable_convolutional_layer()->::encephal_alpha::ConvolutionalLayerData::MergeFrom(from.convolutional_layer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PipeNode_PipeNodeData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PipeNode_PipeNodeData::CopyFrom(const PipeNode_PipeNodeData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipeNode_PipeNodeData::IsInitialized() const {

  if (has_dropout_layer()) {
    if (!this->dropout_layer().IsInitialized()) return false;
  }
  if (has_perceptron_layer()) {
    if (!this->perceptron_layer().IsInitialized()) return false;
  }
  if (has_convolutional_layer()) {
    if (!this->convolutional_layer().IsInitialized()) return false;
  }
  return true;
}

void PipeNode_PipeNodeData::Swap(PipeNode_PipeNodeData* other) {
  if (other != this) {
    std::swap(full_connexion_, other->full_connexion_);
    std::swap(dropout_layer_, other->dropout_layer_);
    std::swap(perceptron_layer_, other->perceptron_layer_);
    std::swap(convolutional_layer_, other->convolutional_layer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PipeNode_PipeNodeData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PipeNode_PipeNodeData_descriptor_;
  metadata.reflection = PipeNode_PipeNodeData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PipeNode::kIndexFieldNumber;
const int PipeNode::kInputDatatypeFieldNumber;
const int PipeNode::kOutputDatatypeFieldNumber;
const int PipeNode::kInputSocketIndexFieldNumber;
const int PipeNode::kOutputSocketIndexFieldNumber;
const int PipeNode::kNodeTypeFieldNumber;
const int PipeNode::kDataFieldNumber;
#endif  // !_MSC_VER

PipeNode::PipeNode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PipeNode::InitAsDefaultInstance() {
  input_datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
  output_datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
  data_ = const_cast< ::encephal_alpha::PipeNode_PipeNodeData*>(&::encephal_alpha::PipeNode_PipeNodeData::default_instance());
}

PipeNode::PipeNode(const PipeNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PipeNode::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  input_datatype_ = NULL;
  output_datatype_ = NULL;
  input_socket_index_ = 0u;
  output_socket_index_ = 0u;
  node_type_ = 1;
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PipeNode::~PipeNode() {
  SharedDtor();
}

void PipeNode::SharedDtor() {
  if (this != default_instance_) {
    delete input_datatype_;
    delete output_datatype_;
    delete data_;
  }
}

void PipeNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PipeNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PipeNode_descriptor_;
}

const PipeNode& PipeNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

PipeNode* PipeNode::default_instance_ = NULL;

PipeNode* PipeNode::New() const {
  return new PipeNode;
}

void PipeNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_input_datatype()) {
      if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
    }
    if (has_output_datatype()) {
      if (output_datatype_ != NULL) output_datatype_->::encephal_alpha::DataType::Clear();
    }
    input_socket_index_ = 0u;
    output_socket_index_ = 0u;
    node_type_ = 1;
    if (has_data()) {
      if (data_ != NULL) data_->::encephal_alpha::PipeNode_PipeNodeData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PipeNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input_datatype;
        break;
      }

      // required .encephal_alpha.DataType input_datatype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input_datatype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_output_datatype;
        break;
      }

      // required .encephal_alpha.DataType output_datatype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_output_datatype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_output_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_input_socket_index;
        break;
      }

      // required uint32 input_socket_index = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_input_socket_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &input_socket_index_)));
          set_has_input_socket_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_output_socket_index;
        break;
      }

      // required uint32 output_socket_index = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_output_socket_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &output_socket_index_)));
          set_has_output_socket_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_node_type;
        break;
      }

      // required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_node_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::encephal_alpha::PipeNode_PipeNodeType_IsValid(value)) {
            set_node_type(static_cast< ::encephal_alpha::PipeNode_PipeNodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_data;
        break;
      }

      // required .encephal_alpha.PipeNode.PipeNodeData data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PipeNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required .encephal_alpha.DataType input_datatype = 2;
  if (has_input_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->input_datatype(), output);
  }

  // required .encephal_alpha.DataType output_datatype = 3;
  if (has_output_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->output_datatype(), output);
  }

  // required uint32 input_socket_index = 4;
  if (has_input_socket_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->input_socket_index(), output);
  }

  // required uint32 output_socket_index = 5;
  if (has_output_socket_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->output_socket_index(), output);
  }

  // required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
  if (has_node_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->node_type(), output);
  }

  // required .encephal_alpha.PipeNode.PipeNodeData data = 7;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PipeNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // required .encephal_alpha.DataType input_datatype = 2;
  if (has_input_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->input_datatype(), target);
  }

  // required .encephal_alpha.DataType output_datatype = 3;
  if (has_output_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->output_datatype(), target);
  }

  // required uint32 input_socket_index = 4;
  if (has_input_socket_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->input_socket_index(), target);
  }

  // required uint32 output_socket_index = 5;
  if (has_output_socket_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->output_socket_index(), target);
  }

  // required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
  if (has_node_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->node_type(), target);
  }

  // required .encephal_alpha.PipeNode.PipeNodeData data = 7;
  if (has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PipeNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required .encephal_alpha.DataType input_datatype = 2;
    if (has_input_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_datatype());
    }

    // required .encephal_alpha.DataType output_datatype = 3;
    if (has_output_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output_datatype());
    }

    // required uint32 input_socket_index = 4;
    if (has_input_socket_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->input_socket_index());
    }

    // required uint32 output_socket_index = 5;
    if (has_output_socket_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->output_socket_index());
    }

    // required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
    if (has_node_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->node_type());
    }

    // required .encephal_alpha.PipeNode.PipeNodeData data = 7;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PipeNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PipeNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PipeNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PipeNode::MergeFrom(const PipeNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_input_datatype()) {
      mutable_input_datatype()->::encephal_alpha::DataType::MergeFrom(from.input_datatype());
    }
    if (from.has_output_datatype()) {
      mutable_output_datatype()->::encephal_alpha::DataType::MergeFrom(from.output_datatype());
    }
    if (from.has_input_socket_index()) {
      set_input_socket_index(from.input_socket_index());
    }
    if (from.has_output_socket_index()) {
      set_output_socket_index(from.output_socket_index());
    }
    if (from.has_node_type()) {
      set_node_type(from.node_type());
    }
    if (from.has_data()) {
      mutable_data()->::encephal_alpha::PipeNode_PipeNodeData::MergeFrom(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PipeNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PipeNode::CopyFrom(const PipeNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipeNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  if (has_input_datatype()) {
    if (!this->input_datatype().IsInitialized()) return false;
  }
  if (has_output_datatype()) {
    if (!this->output_datatype().IsInitialized()) return false;
  }
  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void PipeNode::Swap(PipeNode* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(input_datatype_, other->input_datatype_);
    std::swap(output_datatype_, other->output_datatype_);
    std::swap(input_socket_index_, other->input_socket_index_);
    std::swap(output_socket_index_, other->output_socket_index_);
    std::swap(node_type_, other->node_type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PipeNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PipeNode_descriptor_;
  metadata.reflection = PipeNode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Connection::kSocketIndexFieldNumber;
const int Connection::kNodeIndexFieldNumber;
#endif  // !_MSC_VER

Connection::Connection()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Connection::InitAsDefaultInstance() {
}

Connection::Connection(const Connection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Connection::SharedCtor() {
  _cached_size_ = 0;
  socket_index_ = 0u;
  node_index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Connection::~Connection() {
  SharedDtor();
}

void Connection::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Connection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Connection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Connection_descriptor_;
}

const Connection& Connection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

Connection* Connection::default_instance_ = NULL;

Connection* Connection::New() const {
  return new Connection;
}

void Connection::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    socket_index_ = 0u;
    node_index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Connection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 socket_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &socket_index_)));
          set_has_socket_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_node_index;
        break;
      }

      // required uint32 node_index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_node_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_index_)));
          set_has_node_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Connection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 socket_index = 1;
  if (has_socket_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->socket_index(), output);
  }

  // required uint32 node_index = 2;
  if (has_node_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->node_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Connection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 socket_index = 1;
  if (has_socket_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->socket_index(), target);
  }

  // required uint32 node_index = 2;
  if (has_node_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->node_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Connection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 socket_index = 1;
    if (has_socket_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->socket_index());
    }

    // required uint32 node_index = 2;
    if (has_node_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Connection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Connection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Connection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Connection::MergeFrom(const Connection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_socket_index()) {
      set_socket_index(from.socket_index());
    }
    if (from.has_node_index()) {
      set_node_index(from.node_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Connection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Connection::CopyFrom(const Connection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Connection::Swap(Connection* other) {
  if (other != this) {
    std::swap(socket_index_, other->socket_index_);
    std::swap(node_index_, other->node_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Connection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Connection_descriptor_;
  metadata.reflection = Connection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Socket::kIndexFieldNumber;
const int Socket::kDatatypeFieldNumber;
#endif  // !_MSC_VER

Socket::Socket()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Socket::InitAsDefaultInstance() {
  datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
}

Socket::Socket(const Socket& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Socket::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  datatype_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Socket::~Socket() {
  SharedDtor();
}

void Socket::SharedDtor() {
  if (this != default_instance_) {
    delete datatype_;
  }
}

void Socket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Socket::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Socket_descriptor_;
}

const Socket& Socket::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

Socket* Socket::default_instance_ = NULL;

Socket* Socket::New() const {
  return new Socket;
}

void Socket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_datatype()) {
      if (datatype_ != NULL) datatype_->::encephal_alpha::DataType::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Socket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datatype;
        break;
      }

      // required .encephal_alpha.DataType datatype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datatype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Socket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required .encephal_alpha.DataType datatype = 2;
  if (has_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->datatype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Socket::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // required .encephal_alpha.DataType datatype = 2;
  if (has_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->datatype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Socket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required .encephal_alpha.DataType datatype = 2;
    if (has_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->datatype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Socket::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Socket* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Socket*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Socket::MergeFrom(const Socket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_datatype()) {
      mutable_datatype()->::encephal_alpha::DataType::MergeFrom(from.datatype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Socket::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Socket::CopyFrom(const Socket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Socket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_datatype()) {
    if (!this->datatype().IsInitialized()) return false;
  }
  return true;
}

void Socket::Swap(Socket* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(datatype_, other->datatype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Socket::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Socket_descriptor_;
  metadata.reflection = Socket_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SchedulerNodeLayer::kNodesFieldNumber;
#endif  // !_MSC_VER

SchedulerNodeLayer::SchedulerNodeLayer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SchedulerNodeLayer::InitAsDefaultInstance() {
}

SchedulerNodeLayer::SchedulerNodeLayer(const SchedulerNodeLayer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SchedulerNodeLayer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SchedulerNodeLayer::~SchedulerNodeLayer() {
  SharedDtor();
}

void SchedulerNodeLayer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SchedulerNodeLayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SchedulerNodeLayer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SchedulerNodeLayer_descriptor_;
}

const SchedulerNodeLayer& SchedulerNodeLayer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

SchedulerNodeLayer* SchedulerNodeLayer::default_instance_ = NULL;

SchedulerNodeLayer* SchedulerNodeLayer::New() const {
  return new SchedulerNodeLayer;
}

void SchedulerNodeLayer::Clear() {
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SchedulerNodeLayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .encephal_alpha.PipeNode nodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_nodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SchedulerNodeLayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .encephal_alpha.PipeNode nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SchedulerNodeLayer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .encephal_alpha.PipeNode nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nodes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SchedulerNodeLayer::ByteSize() const {
  int total_size = 0;

  // repeated .encephal_alpha.PipeNode nodes = 1;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SchedulerNodeLayer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SchedulerNodeLayer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SchedulerNodeLayer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SchedulerNodeLayer::MergeFrom(const SchedulerNodeLayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SchedulerNodeLayer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SchedulerNodeLayer::CopyFrom(const SchedulerNodeLayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedulerNodeLayer::IsInitialized() const {

  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void SchedulerNodeLayer::Swap(SchedulerNodeLayer* other) {
  if (other != this) {
    nodes_.Swap(&other->nodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SchedulerNodeLayer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SchedulerNodeLayer_descriptor_;
  metadata.reflection = SchedulerNodeLayer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Graph::kNodeLayersFieldNumber;
const int Graph::kSocketsFieldNumber;
const int Graph::kEntrySocketFieldNumber;
const int Graph::kExitSocketFieldNumber;
#endif  // !_MSC_VER

Graph::Graph()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Graph::InitAsDefaultInstance() {
}

Graph::Graph(const Graph& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Graph::SharedCtor() {
  _cached_size_ = 0;
  entry_socket_ = 0u;
  exit_socket_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Graph::~Graph() {
  SharedDtor();
}

void Graph::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Graph::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Graph::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Graph_descriptor_;
}

const Graph& Graph::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

Graph* Graph::default_instance_ = NULL;

Graph* Graph::New() const {
  return new Graph;
}

void Graph::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    entry_socket_ = 0u;
    exit_socket_ = 0u;
  }
  node_layers_.Clear();
  sockets_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Graph::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_node_layers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_node_layers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_node_layers;
        if (input->ExpectTag(18)) goto parse_sockets;
        break;
      }

      // repeated .encephal_alpha.Socket sockets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sockets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sockets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sockets;
        if (input->ExpectTag(24)) goto parse_entry_socket;
        break;
      }

      // required uint32 entry_socket = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_entry_socket:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entry_socket_)));
          set_has_entry_socket();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_exit_socket;
        break;
      }

      // required uint32 exit_socket = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exit_socket:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exit_socket_)));
          set_has_exit_socket();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Graph::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
  for (int i = 0; i < this->node_layers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node_layers(i), output);
  }

  // repeated .encephal_alpha.Socket sockets = 2;
  for (int i = 0; i < this->sockets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->sockets(i), output);
  }

  // required uint32 entry_socket = 3;
  if (has_entry_socket()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->entry_socket(), output);
  }

  // required uint32 exit_socket = 4;
  if (has_exit_socket()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->exit_socket(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Graph::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
  for (int i = 0; i < this->node_layers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node_layers(i), target);
  }

  // repeated .encephal_alpha.Socket sockets = 2;
  for (int i = 0; i < this->sockets_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->sockets(i), target);
  }

  // required uint32 entry_socket = 3;
  if (has_entry_socket()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->entry_socket(), target);
  }

  // required uint32 exit_socket = 4;
  if (has_exit_socket()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->exit_socket(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Graph::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required uint32 entry_socket = 3;
    if (has_entry_socket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entry_socket());
    }

    // required uint32 exit_socket = 4;
    if (has_exit_socket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exit_socket());
    }

  }
  // repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
  total_size += 1 * this->node_layers_size();
  for (int i = 0; i < this->node_layers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->node_layers(i));
  }

  // repeated .encephal_alpha.Socket sockets = 2;
  total_size += 1 * this->sockets_size();
  for (int i = 0; i < this->sockets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sockets(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Graph::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Graph* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Graph*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Graph::MergeFrom(const Graph& from) {
  GOOGLE_CHECK_NE(&from, this);
  node_layers_.MergeFrom(from.node_layers_);
  sockets_.MergeFrom(from.sockets_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_entry_socket()) {
      set_entry_socket(from.entry_socket());
    }
    if (from.has_exit_socket()) {
      set_exit_socket(from.exit_socket());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Graph::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Graph::CopyFrom(const Graph& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Graph::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  for (int i = 0; i < node_layers_size(); i++) {
    if (!this->node_layers(i).IsInitialized()) return false;
  }
  for (int i = 0; i < sockets_size(); i++) {
    if (!this->sockets(i).IsInitialized()) return false;
  }
  return true;
}

void Graph::Swap(Graph* other) {
  if (other != this) {
    node_layers_.Swap(&other->node_layers_);
    sockets_.Swap(&other->sockets_);
    std::swap(entry_socket_, other->entry_socket_);
    std::swap(exit_socket_, other->exit_socket_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Graph::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Graph_descriptor_;
  metadata.reflection = Graph_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DataArray::kFloatVectorFieldNumber;
const int DataArray::kUint32VectorFieldNumber;
const int DataArray::kUint64VectorFieldNumber;
const int DataArray::kBoolVectorFieldNumber;
#endif  // !_MSC_VER

DataArray::DataArray()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataArray::InitAsDefaultInstance() {
}

DataArray::DataArray(const DataArray& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataArray::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataArray::~DataArray() {
  SharedDtor();
}

void DataArray::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DataArray::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataArray::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataArray_descriptor_;
}

const DataArray& DataArray::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

DataArray* DataArray::default_instance_ = NULL;

DataArray* DataArray::New() const {
  return new DataArray;
}

void DataArray::Clear() {
  float_vector_.Clear();
  uint32_vector_.Clear();
  uint64_vector_.Clear();
  bool_vector_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataArray::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float float_vector = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_float_vector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_float_vector())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_float_vector())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_float_vector;
        if (input->ExpectTag(16)) goto parse_uint32_vector;
        break;
      }

      // repeated uint32 uint32_vector = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uint32_vector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_uint32_vector())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_uint32_vector())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uint32_vector;
        if (input->ExpectTag(24)) goto parse_uint64_vector;
        break;
      }

      // repeated uint64 uint64_vector = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uint64_vector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_uint64_vector())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_uint64_vector())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_uint64_vector;
        if (input->ExpectTag(32)) goto parse_bool_vector;
        break;
      }

      // repeated bool bool_vector = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bool_vector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 32, input, this->mutable_bool_vector())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_bool_vector())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_bool_vector;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataArray::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated float float_vector = 1;
  for (int i = 0; i < this->float_vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->float_vector(i), output);
  }

  // repeated uint32 uint32_vector = 2;
  for (int i = 0; i < this->uint32_vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->uint32_vector(i), output);
  }

  // repeated uint64 uint64_vector = 3;
  for (int i = 0; i < this->uint64_vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->uint64_vector(i), output);
  }

  // repeated bool bool_vector = 4;
  for (int i = 0; i < this->bool_vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      4, this->bool_vector(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataArray::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated float float_vector = 1;
  for (int i = 0; i < this->float_vector_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->float_vector(i), target);
  }

  // repeated uint32 uint32_vector = 2;
  for (int i = 0; i < this->uint32_vector_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->uint32_vector(i), target);
  }

  // repeated uint64 uint64_vector = 3;
  for (int i = 0; i < this->uint64_vector_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->uint64_vector(i), target);
  }

  // repeated bool bool_vector = 4;
  for (int i = 0; i < this->bool_vector_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(4, this->bool_vector(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataArray::ByteSize() const {
  int total_size = 0;

  // repeated float float_vector = 1;
  {
    int data_size = 0;
    data_size = 4 * this->float_vector_size();
    total_size += 1 * this->float_vector_size() + data_size;
  }

  // repeated uint32 uint32_vector = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->uint32_vector_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->uint32_vector(i));
    }
    total_size += 1 * this->uint32_vector_size() + data_size;
  }

  // repeated uint64 uint64_vector = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->uint64_vector_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->uint64_vector(i));
    }
    total_size += 1 * this->uint64_vector_size() + data_size;
  }

  // repeated bool bool_vector = 4;
  {
    int data_size = 0;
    data_size = 1 * this->bool_vector_size();
    total_size += 1 * this->bool_vector_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataArray::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataArray* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataArray*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataArray::MergeFrom(const DataArray& from) {
  GOOGLE_CHECK_NE(&from, this);
  float_vector_.MergeFrom(from.float_vector_);
  uint32_vector_.MergeFrom(from.uint32_vector_);
  uint64_vector_.MergeFrom(from.uint64_vector_);
  bool_vector_.MergeFrom(from.bool_vector_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataArray::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataArray::CopyFrom(const DataArray& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataArray::IsInitialized() const {

  return true;
}

void DataArray::Swap(DataArray* other) {
  if (other != this) {
    float_vector_.Swap(&other->float_vector_);
    uint32_vector_.Swap(&other->uint32_vector_);
    uint64_vector_.Swap(&other->uint64_vector_);
    bool_vector_.Swap(&other->bool_vector_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataArray::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataArray_descriptor_;
  metadata.reflection = DataArray_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TrainingDataEntry::kInputDatatypeFieldNumber;
const int TrainingDataEntry::kOutputDatatypeFieldNumber;
const int TrainingDataEntry::kInputFieldNumber;
const int TrainingDataEntry::kLabelFieldNumber;
#endif  // !_MSC_VER

TrainingDataEntry::TrainingDataEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TrainingDataEntry::InitAsDefaultInstance() {
  input_datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
  output_datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
  input_ = const_cast< ::encephal_alpha::DataArray*>(&::encephal_alpha::DataArray::default_instance());
  label_ = const_cast< ::encephal_alpha::DataArray*>(&::encephal_alpha::DataArray::default_instance());
}

TrainingDataEntry::TrainingDataEntry(const TrainingDataEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TrainingDataEntry::SharedCtor() {
  _cached_size_ = 0;
  input_datatype_ = NULL;
  output_datatype_ = NULL;
  input_ = NULL;
  label_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrainingDataEntry::~TrainingDataEntry() {
  SharedDtor();
}

void TrainingDataEntry::SharedDtor() {
  if (this != default_instance_) {
    delete input_datatype_;
    delete output_datatype_;
    delete input_;
    delete label_;
  }
}

void TrainingDataEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrainingDataEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrainingDataEntry_descriptor_;
}

const TrainingDataEntry& TrainingDataEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

TrainingDataEntry* TrainingDataEntry::default_instance_ = NULL;

TrainingDataEntry* TrainingDataEntry::New() const {
  return new TrainingDataEntry;
}

void TrainingDataEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_input_datatype()) {
      if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
    }
    if (has_output_datatype()) {
      if (output_datatype_ != NULL) output_datatype_->::encephal_alpha::DataType::Clear();
    }
    if (has_input()) {
      if (input_ != NULL) input_->::encephal_alpha::DataArray::Clear();
    }
    if (has_label()) {
      if (label_ != NULL) label_->::encephal_alpha::DataArray::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TrainingDataEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .encephal_alpha.DataType input_datatype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_output_datatype;
        break;
      }

      // required .encephal_alpha.DataType output_datatype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_output_datatype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_output_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_input;
        break;
      }

      // required .encephal_alpha.DataArray input = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_label;
        break;
      }

      // required .encephal_alpha.DataArray label = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TrainingDataEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .encephal_alpha.DataType input_datatype = 1;
  if (has_input_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->input_datatype(), output);
  }

  // required .encephal_alpha.DataType output_datatype = 2;
  if (has_output_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->output_datatype(), output);
  }

  // required .encephal_alpha.DataArray input = 3;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->input(), output);
  }

  // required .encephal_alpha.DataArray label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TrainingDataEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .encephal_alpha.DataType input_datatype = 1;
  if (has_input_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->input_datatype(), target);
  }

  // required .encephal_alpha.DataType output_datatype = 2;
  if (has_output_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->output_datatype(), target);
  }

  // required .encephal_alpha.DataArray input = 3;
  if (has_input()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->input(), target);
  }

  // required .encephal_alpha.DataArray label = 4;
  if (has_label()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TrainingDataEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .encephal_alpha.DataType input_datatype = 1;
    if (has_input_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_datatype());
    }

    // required .encephal_alpha.DataType output_datatype = 2;
    if (has_output_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output_datatype());
    }

    // required .encephal_alpha.DataArray input = 3;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

    // required .encephal_alpha.DataArray label = 4;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrainingDataEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TrainingDataEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TrainingDataEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrainingDataEntry::MergeFrom(const TrainingDataEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_input_datatype()) {
      mutable_input_datatype()->::encephal_alpha::DataType::MergeFrom(from.input_datatype());
    }
    if (from.has_output_datatype()) {
      mutable_output_datatype()->::encephal_alpha::DataType::MergeFrom(from.output_datatype());
    }
    if (from.has_input()) {
      mutable_input()->::encephal_alpha::DataArray::MergeFrom(from.input());
    }
    if (from.has_label()) {
      mutable_label()->::encephal_alpha::DataArray::MergeFrom(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TrainingDataEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrainingDataEntry::CopyFrom(const TrainingDataEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainingDataEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_input_datatype()) {
    if (!this->input_datatype().IsInitialized()) return false;
  }
  if (has_output_datatype()) {
    if (!this->output_datatype().IsInitialized()) return false;
  }
  return true;
}

void TrainingDataEntry::Swap(TrainingDataEntry* other) {
  if (other != this) {
    std::swap(input_datatype_, other->input_datatype_);
    std::swap(output_datatype_, other->output_datatype_);
    std::swap(input_, other->input_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TrainingDataEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrainingDataEntry_descriptor_;
  metadata.reflection = TrainingDataEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TestingDataEntry::kInputDatatypeFieldNumber;
const int TestingDataEntry::kEntriesFieldNumber;
#endif  // !_MSC_VER

TestingDataEntry::TestingDataEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TestingDataEntry::InitAsDefaultInstance() {
  input_datatype_ = const_cast< ::encephal_alpha::DataType*>(&::encephal_alpha::DataType::default_instance());
  entries_ = const_cast< ::encephal_alpha::DataArray*>(&::encephal_alpha::DataArray::default_instance());
}

TestingDataEntry::TestingDataEntry(const TestingDataEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TestingDataEntry::SharedCtor() {
  _cached_size_ = 0;
  input_datatype_ = NULL;
  entries_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestingDataEntry::~TestingDataEntry() {
  SharedDtor();
}

void TestingDataEntry::SharedDtor() {
  if (this != default_instance_) {
    delete input_datatype_;
    delete entries_;
  }
}

void TestingDataEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TestingDataEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TestingDataEntry_descriptor_;
}

const TestingDataEntry& TestingDataEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

TestingDataEntry* TestingDataEntry::default_instance_ = NULL;

TestingDataEntry* TestingDataEntry::New() const {
  return new TestingDataEntry;
}

void TestingDataEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_input_datatype()) {
      if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
    }
    if (has_entries()) {
      if (entries_ != NULL) entries_->::encephal_alpha::DataArray::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TestingDataEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .encephal_alpha.DataType input_datatype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input_datatype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        break;
      }

      // required .encephal_alpha.DataArray entries = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TestingDataEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .encephal_alpha.DataType input_datatype = 1;
  if (has_input_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->input_datatype(), output);
  }

  // required .encephal_alpha.DataArray entries = 2;
  if (has_entries()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entries(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TestingDataEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .encephal_alpha.DataType input_datatype = 1;
  if (has_input_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->input_datatype(), target);
  }

  // required .encephal_alpha.DataArray entries = 2;
  if (has_entries()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entries(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TestingDataEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .encephal_alpha.DataType input_datatype = 1;
    if (has_input_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_datatype());
    }

    // required .encephal_alpha.DataArray entries = 2;
    if (has_entries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->entries());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestingDataEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TestingDataEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TestingDataEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TestingDataEntry::MergeFrom(const TestingDataEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_input_datatype()) {
      mutable_input_datatype()->::encephal_alpha::DataType::MergeFrom(from.input_datatype());
    }
    if (from.has_entries()) {
      mutable_entries()->::encephal_alpha::DataArray::MergeFrom(from.entries());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TestingDataEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TestingDataEntry::CopyFrom(const TestingDataEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestingDataEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_input_datatype()) {
    if (!this->input_datatype().IsInitialized()) return false;
  }
  return true;
}

void TestingDataEntry::Swap(TestingDataEntry* other) {
  if (other != this) {
    std::swap(input_datatype_, other->input_datatype_);
    std::swap(entries_, other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TestingDataEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TestingDataEntry_descriptor_;
  metadata.reflection = TestingDataEntry_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DataEntry_DataEntryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataEntry_DataEntryType_descriptor_;
}
bool DataEntry_DataEntryType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DataEntry_DataEntryType DataEntry::TRAIN;
const DataEntry_DataEntryType DataEntry::TEST;
const DataEntry_DataEntryType DataEntry::DataEntryType_MIN;
const DataEntry_DataEntryType DataEntry::DataEntryType_MAX;
const int DataEntry::DataEntryType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DataEntry::kTypeFieldNumber;
const int DataEntry::kTrainDataEntryFieldNumber;
const int DataEntry::kTestDataEntryFieldNumber;
#endif  // !_MSC_VER

DataEntry::DataEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataEntry::InitAsDefaultInstance() {
  traindataentry_ = const_cast< ::encephal_alpha::TrainingDataEntry*>(&::encephal_alpha::TrainingDataEntry::default_instance());
  testdataentry_ = const_cast< ::encephal_alpha::TestingDataEntry*>(&::encephal_alpha::TestingDataEntry::default_instance());
}

DataEntry::DataEntry(const DataEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataEntry::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  traindataentry_ = NULL;
  testdataentry_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataEntry::~DataEntry() {
  SharedDtor();
}

void DataEntry::SharedDtor() {
  if (this != default_instance_) {
    delete traindataentry_;
    delete testdataentry_;
  }
}

void DataEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataEntry_descriptor_;
}

const DataEntry& DataEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encephal_5falpha_2eproto();
  return *default_instance_;
}

DataEntry* DataEntry::default_instance_ = NULL;

DataEntry* DataEntry::New() const {
  return new DataEntry;
}

void DataEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_traindataentry()) {
      if (traindataentry_ != NULL) traindataentry_->::encephal_alpha::TrainingDataEntry::Clear();
    }
    if (has_testdataentry()) {
      if (testdataentry_ != NULL) testdataentry_->::encephal_alpha::TestingDataEntry::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .encephal_alpha.DataEntry.DataEntryType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::encephal_alpha::DataEntry_DataEntryType_IsValid(value)) {
            set_type(static_cast< ::encephal_alpha::DataEntry_DataEntryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_trainDataEntry;
        break;
      }

      // optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trainDataEntry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traindataentry()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_testDataEntry;
        break;
      }

      // optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_testDataEntry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_testdataentry()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .encephal_alpha.DataEntry.DataEntryType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
  if (has_traindataentry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->traindataentry(), output);
  }

  // optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
  if (has_testdataentry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->testdataentry(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .encephal_alpha.DataEntry.DataEntryType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
  if (has_traindataentry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->traindataentry(), target);
  }

  // optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
  if (has_testdataentry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->testdataentry(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .encephal_alpha.DataEntry.DataEntryType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
    if (has_traindataentry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->traindataentry());
    }

    // optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
    if (has_testdataentry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->testdataentry());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataEntry::MergeFrom(const DataEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_traindataentry()) {
      mutable_traindataentry()->::encephal_alpha::TrainingDataEntry::MergeFrom(from.traindataentry());
    }
    if (from.has_testdataentry()) {
      mutable_testdataentry()->::encephal_alpha::TestingDataEntry::MergeFrom(from.testdataentry());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataEntry::CopyFrom(const DataEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_traindataentry()) {
    if (!this->traindataentry().IsInitialized()) return false;
  }
  if (has_testdataentry()) {
    if (!this->testdataentry().IsInitialized()) return false;
  }
  return true;
}

void DataEntry::Swap(DataEntry* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(traindataentry_, other->traindataentry_);
    std::swap(testdataentry_, other->testdataentry_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataEntry_descriptor_;
  metadata.reflection = DataEntry_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace encephal_alpha

// @@protoc_insertion_point(global_scope)
