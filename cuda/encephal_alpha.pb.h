// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encephal_alpha.proto

#ifndef PROTOBUF_encephal_5falpha_2eproto__INCLUDED
#define PROTOBUF_encephal_5falpha_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace encephal_alpha {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_encephal_5falpha_2eproto();
void protobuf_AssignDesc_encephal_5falpha_2eproto();
void protobuf_ShutdownFile_encephal_5falpha_2eproto();

class DataType;
class PerceptronLayerData;
class ConvolutionalLayerData;
class DropoutLayerData;
class FullConnexionLayerData;
class PipeNode;
class PipeNode_PipeNodeData;
class Connection;
class Socket;
class SchedulerNodeLayer;
class Graph;
class DataArray;
class TrainingDataEntry;
class TestingDataEntry;
class DataEntry;

enum DataType_NumericType {
  DataType_NumericType_FLOAT = 1,
  DataType_NumericType_INT32 = 2,
  DataType_NumericType_INT64 = 3,
  DataType_NumericType_BOOL = 4
};
bool DataType_NumericType_IsValid(int value);
const DataType_NumericType DataType_NumericType_NumericType_MIN = DataType_NumericType_FLOAT;
const DataType_NumericType DataType_NumericType_NumericType_MAX = DataType_NumericType_BOOL;
const int DataType_NumericType_NumericType_ARRAYSIZE = DataType_NumericType_NumericType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_NumericType_descriptor();
inline const ::std::string& DataType_NumericType_Name(DataType_NumericType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_NumericType_descriptor(), value);
}
inline bool DataType_NumericType_Parse(
    const ::std::string& name, DataType_NumericType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType_NumericType>(
    DataType_NumericType_descriptor(), name, value);
}
enum ConvolutionalLayerData_ZeroPaddingType {
  ConvolutionalLayerData_ZeroPaddingType_VALID = 1,
  ConvolutionalLayerData_ZeroPaddingType_SAME = 2,
  ConvolutionalLayerData_ZeroPaddingType_FULL = 3
};
bool ConvolutionalLayerData_ZeroPaddingType_IsValid(int value);
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_MIN = ConvolutionalLayerData_ZeroPaddingType_VALID;
const ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_MAX = ConvolutionalLayerData_ZeroPaddingType_FULL;
const int ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_ARRAYSIZE = ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConvolutionalLayerData_ZeroPaddingType_descriptor();
inline const ::std::string& ConvolutionalLayerData_ZeroPaddingType_Name(ConvolutionalLayerData_ZeroPaddingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConvolutionalLayerData_ZeroPaddingType_descriptor(), value);
}
inline bool ConvolutionalLayerData_ZeroPaddingType_Parse(
    const ::std::string& name, ConvolutionalLayerData_ZeroPaddingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConvolutionalLayerData_ZeroPaddingType>(
    ConvolutionalLayerData_ZeroPaddingType_descriptor(), name, value);
}
enum PipeNode_PipeNodeType {
  PipeNode_PipeNodeType_FULL_CONNEXION = 1,
  PipeNode_PipeNodeType_DROPOUT_LAYER = 2,
  PipeNode_PipeNodeType_PERCEPTRON_LAYER = 3,
  PipeNode_PipeNodeType_CONVOLUTIONAL_LAYER = 4
};
bool PipeNode_PipeNodeType_IsValid(int value);
const PipeNode_PipeNodeType PipeNode_PipeNodeType_PipeNodeType_MIN = PipeNode_PipeNodeType_FULL_CONNEXION;
const PipeNode_PipeNodeType PipeNode_PipeNodeType_PipeNodeType_MAX = PipeNode_PipeNodeType_CONVOLUTIONAL_LAYER;
const int PipeNode_PipeNodeType_PipeNodeType_ARRAYSIZE = PipeNode_PipeNodeType_PipeNodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PipeNode_PipeNodeType_descriptor();
inline const ::std::string& PipeNode_PipeNodeType_Name(PipeNode_PipeNodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PipeNode_PipeNodeType_descriptor(), value);
}
inline bool PipeNode_PipeNodeType_Parse(
    const ::std::string& name, PipeNode_PipeNodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PipeNode_PipeNodeType>(
    PipeNode_PipeNodeType_descriptor(), name, value);
}
enum DataEntry_DataEntryType {
  DataEntry_DataEntryType_TRAIN = 1,
  DataEntry_DataEntryType_TEST = 2
};
bool DataEntry_DataEntryType_IsValid(int value);
const DataEntry_DataEntryType DataEntry_DataEntryType_DataEntryType_MIN = DataEntry_DataEntryType_TRAIN;
const DataEntry_DataEntryType DataEntry_DataEntryType_DataEntryType_MAX = DataEntry_DataEntryType_TEST;
const int DataEntry_DataEntryType_DataEntryType_ARRAYSIZE = DataEntry_DataEntryType_DataEntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataEntry_DataEntryType_descriptor();
inline const ::std::string& DataEntry_DataEntryType_Name(DataEntry_DataEntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataEntry_DataEntryType_descriptor(), value);
}
inline bool DataEntry_DataEntryType_Parse(
    const ::std::string& name, DataEntry_DataEntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataEntry_DataEntryType>(
    DataEntry_DataEntryType_descriptor(), name, value);
}
enum ActivationFunction {
  NOTHING = 1,
  SIGMOID = 2,
  SOFTMAX = 3
};
bool ActivationFunction_IsValid(int value);
const ActivationFunction ActivationFunction_MIN = NOTHING;
const ActivationFunction ActivationFunction_MAX = SOFTMAX;
const int ActivationFunction_ARRAYSIZE = ActivationFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActivationFunction_descriptor();
inline const ::std::string& ActivationFunction_Name(ActivationFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActivationFunction_descriptor(), value);
}
inline bool ActivationFunction_Parse(
    const ::std::string& name, ActivationFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActivationFunction>(
    ActivationFunction_descriptor(), name, value);
}
// ===================================================================

class DataType : public ::google::protobuf::Message {
 public:
  DataType();
  virtual ~DataType();

  DataType(const DataType& from);

  inline DataType& operator=(const DataType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataType& default_instance();

  void Swap(DataType* other);

  // implements Message ----------------------------------------------

  DataType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataType& from);
  void MergeFrom(const DataType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DataType_NumericType NumericType;
  static const NumericType FLOAT = DataType_NumericType_FLOAT;
  static const NumericType INT32 = DataType_NumericType_INT32;
  static const NumericType INT64 = DataType_NumericType_INT64;
  static const NumericType BOOL = DataType_NumericType_BOOL;
  static inline bool NumericType_IsValid(int value) {
    return DataType_NumericType_IsValid(value);
  }
  static const NumericType NumericType_MIN =
    DataType_NumericType_NumericType_MIN;
  static const NumericType NumericType_MAX =
    DataType_NumericType_NumericType_MAX;
  static const int NumericType_ARRAYSIZE =
    DataType_NumericType_NumericType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NumericType_descriptor() {
    return DataType_NumericType_descriptor();
  }
  static inline const ::std::string& NumericType_Name(NumericType value) {
    return DataType_NumericType_Name(value);
  }
  static inline bool NumericType_Parse(const ::std::string& name,
      NumericType* value) {
    return DataType_NumericType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 dimensions = 1;
  inline int dimensions_size() const;
  inline void clear_dimensions();
  static const int kDimensionsFieldNumber = 1;
  inline ::google::protobuf::uint32 dimensions(int index) const;
  inline void set_dimensions(int index, ::google::protobuf::uint32 value);
  inline void add_dimensions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dimensions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dimensions();

  // required .encephal_alpha.DataType.NumericType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::encephal_alpha::DataType_NumericType type() const;
  inline void set_type(::encephal_alpha::DataType_NumericType value);

  // @@protoc_insertion_point(class_scope:encephal_alpha.DataType)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dimensions_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static DataType* default_instance_;
};
// -------------------------------------------------------------------

class PerceptronLayerData : public ::google::protobuf::Message {
 public:
  PerceptronLayerData();
  virtual ~PerceptronLayerData();

  PerceptronLayerData(const PerceptronLayerData& from);

  inline PerceptronLayerData& operator=(const PerceptronLayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptronLayerData& default_instance();

  void Swap(PerceptronLayerData* other);

  // implements Message ----------------------------------------------

  PerceptronLayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerceptronLayerData& from);
  void MergeFrom(const PerceptronLayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .encephal_alpha.ActivationFunction activation_function = 1;
  inline bool has_activation_function() const;
  inline void clear_activation_function();
  static const int kActivationFunctionFieldNumber = 1;
  inline ::encephal_alpha::ActivationFunction activation_function() const;
  inline void set_activation_function(::encephal_alpha::ActivationFunction value);

  // @@protoc_insertion_point(class_scope:encephal_alpha.PerceptronLayerData)
 private:
  inline void set_has_activation_function();
  inline void clear_has_activation_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int activation_function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static PerceptronLayerData* default_instance_;
};
// -------------------------------------------------------------------

class ConvolutionalLayerData : public ::google::protobuf::Message {
 public:
  ConvolutionalLayerData();
  virtual ~ConvolutionalLayerData();

  ConvolutionalLayerData(const ConvolutionalLayerData& from);

  inline ConvolutionalLayerData& operator=(const ConvolutionalLayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvolutionalLayerData& default_instance();

  void Swap(ConvolutionalLayerData* other);

  // implements Message ----------------------------------------------

  ConvolutionalLayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvolutionalLayerData& from);
  void MergeFrom(const ConvolutionalLayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ConvolutionalLayerData_ZeroPaddingType ZeroPaddingType;
  static const ZeroPaddingType VALID = ConvolutionalLayerData_ZeroPaddingType_VALID;
  static const ZeroPaddingType SAME = ConvolutionalLayerData_ZeroPaddingType_SAME;
  static const ZeroPaddingType FULL = ConvolutionalLayerData_ZeroPaddingType_FULL;
  static inline bool ZeroPaddingType_IsValid(int value) {
    return ConvolutionalLayerData_ZeroPaddingType_IsValid(value);
  }
  static const ZeroPaddingType ZeroPaddingType_MIN =
    ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_MIN;
  static const ZeroPaddingType ZeroPaddingType_MAX =
    ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_MAX;
  static const int ZeroPaddingType_ARRAYSIZE =
    ConvolutionalLayerData_ZeroPaddingType_ZeroPaddingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ZeroPaddingType_descriptor() {
    return ConvolutionalLayerData_ZeroPaddingType_descriptor();
  }
  static inline const ::std::string& ZeroPaddingType_Name(ZeroPaddingType value) {
    return ConvolutionalLayerData_ZeroPaddingType_Name(value);
  }
  static inline bool ZeroPaddingType_Parse(const ::std::string& name,
      ZeroPaddingType* value) {
    return ConvolutionalLayerData_ZeroPaddingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
  inline bool has_zero_padding() const;
  inline void clear_zero_padding();
  static const int kZeroPaddingFieldNumber = 1;
  inline ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType zero_padding() const;
  inline void set_zero_padding(::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType value);

  // repeated uint32 kernel_shape = 2;
  inline int kernel_shape_size() const;
  inline void clear_kernel_shape();
  static const int kKernelShapeFieldNumber = 2;
  inline ::google::protobuf::uint32 kernel_shape(int index) const;
  inline void set_kernel_shape(int index, ::google::protobuf::uint32 value);
  inline void add_kernel_shape(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      kernel_shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_kernel_shape();

  // @@protoc_insertion_point(class_scope:encephal_alpha.ConvolutionalLayerData)
 private:
  inline void set_has_zero_padding();
  inline void clear_has_zero_padding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > kernel_shape_;
  int zero_padding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static ConvolutionalLayerData* default_instance_;
};
// -------------------------------------------------------------------

class DropoutLayerData : public ::google::protobuf::Message {
 public:
  DropoutLayerData();
  virtual ~DropoutLayerData();

  DropoutLayerData(const DropoutLayerData& from);

  inline DropoutLayerData& operator=(const DropoutLayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropoutLayerData& default_instance();

  void Swap(DropoutLayerData* other);

  // implements Message ----------------------------------------------

  DropoutLayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropoutLayerData& from);
  void MergeFrom(const DropoutLayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline float p() const;
  inline void set_p(float value);

  // @@protoc_insertion_point(class_scope:encephal_alpha.DropoutLayerData)
 private:
  inline void set_has_p();
  inline void clear_has_p();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float p_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static DropoutLayerData* default_instance_;
};
// -------------------------------------------------------------------

class FullConnexionLayerData : public ::google::protobuf::Message {
 public:
  FullConnexionLayerData();
  virtual ~FullConnexionLayerData();

  FullConnexionLayerData(const FullConnexionLayerData& from);

  inline FullConnexionLayerData& operator=(const FullConnexionLayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FullConnexionLayerData& default_instance();

  void Swap(FullConnexionLayerData* other);

  // implements Message ----------------------------------------------

  FullConnexionLayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullConnexionLayerData& from);
  void MergeFrom(const FullConnexionLayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:encephal_alpha.FullConnexionLayerData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static FullConnexionLayerData* default_instance_;
};
// -------------------------------------------------------------------

class PipeNode_PipeNodeData : public ::google::protobuf::Message {
 public:
  PipeNode_PipeNodeData();
  virtual ~PipeNode_PipeNodeData();

  PipeNode_PipeNodeData(const PipeNode_PipeNodeData& from);

  inline PipeNode_PipeNodeData& operator=(const PipeNode_PipeNodeData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PipeNode_PipeNodeData& default_instance();

  void Swap(PipeNode_PipeNodeData* other);

  // implements Message ----------------------------------------------

  PipeNode_PipeNodeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PipeNode_PipeNodeData& from);
  void MergeFrom(const PipeNode_PipeNodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
  inline bool has_full_connexion() const;
  inline void clear_full_connexion();
  static const int kFullConnexionFieldNumber = 1;
  inline const ::encephal_alpha::FullConnexionLayerData& full_connexion() const;
  inline ::encephal_alpha::FullConnexionLayerData* mutable_full_connexion();
  inline ::encephal_alpha::FullConnexionLayerData* release_full_connexion();
  inline void set_allocated_full_connexion(::encephal_alpha::FullConnexionLayerData* full_connexion);

  // optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
  inline bool has_dropout_layer() const;
  inline void clear_dropout_layer();
  static const int kDropoutLayerFieldNumber = 2;
  inline const ::encephal_alpha::DropoutLayerData& dropout_layer() const;
  inline ::encephal_alpha::DropoutLayerData* mutable_dropout_layer();
  inline ::encephal_alpha::DropoutLayerData* release_dropout_layer();
  inline void set_allocated_dropout_layer(::encephal_alpha::DropoutLayerData* dropout_layer);

  // optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
  inline bool has_perceptron_layer() const;
  inline void clear_perceptron_layer();
  static const int kPerceptronLayerFieldNumber = 3;
  inline const ::encephal_alpha::PerceptronLayerData& perceptron_layer() const;
  inline ::encephal_alpha::PerceptronLayerData* mutable_perceptron_layer();
  inline ::encephal_alpha::PerceptronLayerData* release_perceptron_layer();
  inline void set_allocated_perceptron_layer(::encephal_alpha::PerceptronLayerData* perceptron_layer);

  // optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
  inline bool has_convolutional_layer() const;
  inline void clear_convolutional_layer();
  static const int kConvolutionalLayerFieldNumber = 4;
  inline const ::encephal_alpha::ConvolutionalLayerData& convolutional_layer() const;
  inline ::encephal_alpha::ConvolutionalLayerData* mutable_convolutional_layer();
  inline ::encephal_alpha::ConvolutionalLayerData* release_convolutional_layer();
  inline void set_allocated_convolutional_layer(::encephal_alpha::ConvolutionalLayerData* convolutional_layer);

  // @@protoc_insertion_point(class_scope:encephal_alpha.PipeNode.PipeNodeData)
 private:
  inline void set_has_full_connexion();
  inline void clear_has_full_connexion();
  inline void set_has_dropout_layer();
  inline void clear_has_dropout_layer();
  inline void set_has_perceptron_layer();
  inline void clear_has_perceptron_layer();
  inline void set_has_convolutional_layer();
  inline void clear_has_convolutional_layer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::FullConnexionLayerData* full_connexion_;
  ::encephal_alpha::DropoutLayerData* dropout_layer_;
  ::encephal_alpha::PerceptronLayerData* perceptron_layer_;
  ::encephal_alpha::ConvolutionalLayerData* convolutional_layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static PipeNode_PipeNodeData* default_instance_;
};
// -------------------------------------------------------------------

class PipeNode : public ::google::protobuf::Message {
 public:
  PipeNode();
  virtual ~PipeNode();

  PipeNode(const PipeNode& from);

  inline PipeNode& operator=(const PipeNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PipeNode& default_instance();

  void Swap(PipeNode* other);

  // implements Message ----------------------------------------------

  PipeNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PipeNode& from);
  void MergeFrom(const PipeNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PipeNode_PipeNodeData PipeNodeData;

  typedef PipeNode_PipeNodeType PipeNodeType;
  static const PipeNodeType FULL_CONNEXION = PipeNode_PipeNodeType_FULL_CONNEXION;
  static const PipeNodeType DROPOUT_LAYER = PipeNode_PipeNodeType_DROPOUT_LAYER;
  static const PipeNodeType PERCEPTRON_LAYER = PipeNode_PipeNodeType_PERCEPTRON_LAYER;
  static const PipeNodeType CONVOLUTIONAL_LAYER = PipeNode_PipeNodeType_CONVOLUTIONAL_LAYER;
  static inline bool PipeNodeType_IsValid(int value) {
    return PipeNode_PipeNodeType_IsValid(value);
  }
  static const PipeNodeType PipeNodeType_MIN =
    PipeNode_PipeNodeType_PipeNodeType_MIN;
  static const PipeNodeType PipeNodeType_MAX =
    PipeNode_PipeNodeType_PipeNodeType_MAX;
  static const int PipeNodeType_ARRAYSIZE =
    PipeNode_PipeNodeType_PipeNodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PipeNodeType_descriptor() {
    return PipeNode_PipeNodeType_descriptor();
  }
  static inline const ::std::string& PipeNodeType_Name(PipeNodeType value) {
    return PipeNode_PipeNodeType_Name(value);
  }
  static inline bool PipeNodeType_Parse(const ::std::string& name,
      PipeNodeType* value) {
    return PipeNode_PipeNodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required .encephal_alpha.DataType input_datatype = 2;
  inline bool has_input_datatype() const;
  inline void clear_input_datatype();
  static const int kInputDatatypeFieldNumber = 2;
  inline const ::encephal_alpha::DataType& input_datatype() const;
  inline ::encephal_alpha::DataType* mutable_input_datatype();
  inline ::encephal_alpha::DataType* release_input_datatype();
  inline void set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype);

  // required .encephal_alpha.DataType output_datatype = 3;
  inline bool has_output_datatype() const;
  inline void clear_output_datatype();
  static const int kOutputDatatypeFieldNumber = 3;
  inline const ::encephal_alpha::DataType& output_datatype() const;
  inline ::encephal_alpha::DataType* mutable_output_datatype();
  inline ::encephal_alpha::DataType* release_output_datatype();
  inline void set_allocated_output_datatype(::encephal_alpha::DataType* output_datatype);

  // required uint32 input_socket_index = 4;
  inline bool has_input_socket_index() const;
  inline void clear_input_socket_index();
  static const int kInputSocketIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 input_socket_index() const;
  inline void set_input_socket_index(::google::protobuf::uint32 value);

  // required uint32 output_socket_index = 5;
  inline bool has_output_socket_index() const;
  inline void clear_output_socket_index();
  static const int kOutputSocketIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 output_socket_index() const;
  inline void set_output_socket_index(::google::protobuf::uint32 value);

  // required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 6;
  inline ::encephal_alpha::PipeNode_PipeNodeType node_type() const;
  inline void set_node_type(::encephal_alpha::PipeNode_PipeNodeType value);

  // required .encephal_alpha.PipeNode.PipeNodeData data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::encephal_alpha::PipeNode_PipeNodeData& data() const;
  inline ::encephal_alpha::PipeNode_PipeNodeData* mutable_data();
  inline ::encephal_alpha::PipeNode_PipeNodeData* release_data();
  inline void set_allocated_data(::encephal_alpha::PipeNode_PipeNodeData* data);

  // @@protoc_insertion_point(class_scope:encephal_alpha.PipeNode)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_input_datatype();
  inline void clear_has_input_datatype();
  inline void set_has_output_datatype();
  inline void clear_has_output_datatype();
  inline void set_has_input_socket_index();
  inline void clear_has_input_socket_index();
  inline void set_has_output_socket_index();
  inline void clear_has_output_socket_index();
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::DataType* input_datatype_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 input_socket_index_;
  ::encephal_alpha::DataType* output_datatype_;
  ::google::protobuf::uint32 output_socket_index_;
  int node_type_;
  ::encephal_alpha::PipeNode_PipeNodeData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static PipeNode* default_instance_;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  void Swap(Connection* other);

  // implements Message ----------------------------------------------

  Connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 socket_index = 1;
  inline bool has_socket_index() const;
  inline void clear_socket_index();
  static const int kSocketIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 socket_index() const;
  inline void set_socket_index(::google::protobuf::uint32 value);

  // required uint32 node_index = 2;
  inline bool has_node_index() const;
  inline void clear_node_index();
  static const int kNodeIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 node_index() const;
  inline void set_node_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:encephal_alpha.Connection)
 private:
  inline void set_has_socket_index();
  inline void clear_has_socket_index();
  inline void set_has_node_index();
  inline void clear_has_node_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 socket_index_;
  ::google::protobuf::uint32 node_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static Connection* default_instance_;
};
// -------------------------------------------------------------------

class Socket : public ::google::protobuf::Message {
 public:
  Socket();
  virtual ~Socket();

  Socket(const Socket& from);

  inline Socket& operator=(const Socket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Socket& default_instance();

  void Swap(Socket* other);

  // implements Message ----------------------------------------------

  Socket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Socket& from);
  void MergeFrom(const Socket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required .encephal_alpha.DataType datatype = 2;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDatatypeFieldNumber = 2;
  inline const ::encephal_alpha::DataType& datatype() const;
  inline ::encephal_alpha::DataType* mutable_datatype();
  inline ::encephal_alpha::DataType* release_datatype();
  inline void set_allocated_datatype(::encephal_alpha::DataType* datatype);

  // @@protoc_insertion_point(class_scope:encephal_alpha.Socket)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_datatype();
  inline void clear_has_datatype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::DataType* datatype_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static Socket* default_instance_;
};
// -------------------------------------------------------------------

class SchedulerNodeLayer : public ::google::protobuf::Message {
 public:
  SchedulerNodeLayer();
  virtual ~SchedulerNodeLayer();

  SchedulerNodeLayer(const SchedulerNodeLayer& from);

  inline SchedulerNodeLayer& operator=(const SchedulerNodeLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchedulerNodeLayer& default_instance();

  void Swap(SchedulerNodeLayer* other);

  // implements Message ----------------------------------------------

  SchedulerNodeLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchedulerNodeLayer& from);
  void MergeFrom(const SchedulerNodeLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .encephal_alpha.PipeNode nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::encephal_alpha::PipeNode& nodes(int index) const;
  inline ::encephal_alpha::PipeNode* mutable_nodes(int index);
  inline ::encephal_alpha::PipeNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::PipeNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::PipeNode >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:encephal_alpha.SchedulerNodeLayer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::encephal_alpha::PipeNode > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static SchedulerNodeLayer* default_instance_;
};
// -------------------------------------------------------------------

class Graph : public ::google::protobuf::Message {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  void Swap(Graph* other);

  // implements Message ----------------------------------------------

  Graph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
  inline int node_layers_size() const;
  inline void clear_node_layers();
  static const int kNodeLayersFieldNumber = 1;
  inline const ::encephal_alpha::SchedulerNodeLayer& node_layers(int index) const;
  inline ::encephal_alpha::SchedulerNodeLayer* mutable_node_layers(int index);
  inline ::encephal_alpha::SchedulerNodeLayer* add_node_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::SchedulerNodeLayer >&
      node_layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::SchedulerNodeLayer >*
      mutable_node_layers();

  // repeated .encephal_alpha.Socket sockets = 2;
  inline int sockets_size() const;
  inline void clear_sockets();
  static const int kSocketsFieldNumber = 2;
  inline const ::encephal_alpha::Socket& sockets(int index) const;
  inline ::encephal_alpha::Socket* mutable_sockets(int index);
  inline ::encephal_alpha::Socket* add_sockets();
  inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::Socket >&
      sockets() const;
  inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::Socket >*
      mutable_sockets();

  // required uint32 entry_socket = 3;
  inline bool has_entry_socket() const;
  inline void clear_entry_socket();
  static const int kEntrySocketFieldNumber = 3;
  inline ::google::protobuf::uint32 entry_socket() const;
  inline void set_entry_socket(::google::protobuf::uint32 value);

  // required uint32 exit_socket = 4;
  inline bool has_exit_socket() const;
  inline void clear_exit_socket();
  static const int kExitSocketFieldNumber = 4;
  inline ::google::protobuf::uint32 exit_socket() const;
  inline void set_exit_socket(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:encephal_alpha.Graph)
 private:
  inline void set_has_entry_socket();
  inline void clear_has_entry_socket();
  inline void set_has_exit_socket();
  inline void clear_has_exit_socket();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::encephal_alpha::SchedulerNodeLayer > node_layers_;
  ::google::protobuf::RepeatedPtrField< ::encephal_alpha::Socket > sockets_;
  ::google::protobuf::uint32 entry_socket_;
  ::google::protobuf::uint32 exit_socket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static Graph* default_instance_;
};
// -------------------------------------------------------------------

class DataArray : public ::google::protobuf::Message {
 public:
  DataArray();
  virtual ~DataArray();

  DataArray(const DataArray& from);

  inline DataArray& operator=(const DataArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataArray& default_instance();

  void Swap(DataArray* other);

  // implements Message ----------------------------------------------

  DataArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataArray& from);
  void MergeFrom(const DataArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float float_vector = 1;
  inline int float_vector_size() const;
  inline void clear_float_vector();
  static const int kFloatVectorFieldNumber = 1;
  inline float float_vector(int index) const;
  inline void set_float_vector(int index, float value);
  inline void add_float_vector(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_vector() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_vector();

  // repeated uint32 uint32_vector = 2;
  inline int uint32_vector_size() const;
  inline void clear_uint32_vector();
  static const int kUint32VectorFieldNumber = 2;
  inline ::google::protobuf::uint32 uint32_vector(int index) const;
  inline void set_uint32_vector(int index, ::google::protobuf::uint32 value);
  inline void add_uint32_vector(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uint32_vector() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uint32_vector();

  // repeated uint64 uint64_vector = 3;
  inline int uint64_vector_size() const;
  inline void clear_uint64_vector();
  static const int kUint64VectorFieldNumber = 3;
  inline ::google::protobuf::uint64 uint64_vector(int index) const;
  inline void set_uint64_vector(int index, ::google::protobuf::uint64 value);
  inline void add_uint64_vector(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uint64_vector() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uint64_vector();

  // repeated bool bool_vector = 4;
  inline int bool_vector_size() const;
  inline void clear_bool_vector();
  static const int kBoolVectorFieldNumber = 4;
  inline bool bool_vector(int index) const;
  inline void set_bool_vector(int index, bool value);
  inline void add_bool_vector(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      bool_vector() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_bool_vector();

  // @@protoc_insertion_point(class_scope:encephal_alpha.DataArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > float_vector_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uint32_vector_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uint64_vector_;
  ::google::protobuf::RepeatedField< bool > bool_vector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static DataArray* default_instance_;
};
// -------------------------------------------------------------------

class TrainingDataEntry : public ::google::protobuf::Message {
 public:
  TrainingDataEntry();
  virtual ~TrainingDataEntry();

  TrainingDataEntry(const TrainingDataEntry& from);

  inline TrainingDataEntry& operator=(const TrainingDataEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainingDataEntry& default_instance();

  void Swap(TrainingDataEntry* other);

  // implements Message ----------------------------------------------

  TrainingDataEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainingDataEntry& from);
  void MergeFrom(const TrainingDataEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .encephal_alpha.DataType input_datatype = 1;
  inline bool has_input_datatype() const;
  inline void clear_input_datatype();
  static const int kInputDatatypeFieldNumber = 1;
  inline const ::encephal_alpha::DataType& input_datatype() const;
  inline ::encephal_alpha::DataType* mutable_input_datatype();
  inline ::encephal_alpha::DataType* release_input_datatype();
  inline void set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype);

  // required .encephal_alpha.DataType output_datatype = 2;
  inline bool has_output_datatype() const;
  inline void clear_output_datatype();
  static const int kOutputDatatypeFieldNumber = 2;
  inline const ::encephal_alpha::DataType& output_datatype() const;
  inline ::encephal_alpha::DataType* mutable_output_datatype();
  inline ::encephal_alpha::DataType* release_output_datatype();
  inline void set_allocated_output_datatype(::encephal_alpha::DataType* output_datatype);

  // required .encephal_alpha.DataArray input = 3;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::encephal_alpha::DataArray& input() const;
  inline ::encephal_alpha::DataArray* mutable_input();
  inline ::encephal_alpha::DataArray* release_input();
  inline void set_allocated_input(::encephal_alpha::DataArray* input);

  // required .encephal_alpha.DataArray label = 4;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 4;
  inline const ::encephal_alpha::DataArray& label() const;
  inline ::encephal_alpha::DataArray* mutable_label();
  inline ::encephal_alpha::DataArray* release_label();
  inline void set_allocated_label(::encephal_alpha::DataArray* label);

  // @@protoc_insertion_point(class_scope:encephal_alpha.TrainingDataEntry)
 private:
  inline void set_has_input_datatype();
  inline void clear_has_input_datatype();
  inline void set_has_output_datatype();
  inline void clear_has_output_datatype();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::DataType* input_datatype_;
  ::encephal_alpha::DataType* output_datatype_;
  ::encephal_alpha::DataArray* input_;
  ::encephal_alpha::DataArray* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static TrainingDataEntry* default_instance_;
};
// -------------------------------------------------------------------

class TestingDataEntry : public ::google::protobuf::Message {
 public:
  TestingDataEntry();
  virtual ~TestingDataEntry();

  TestingDataEntry(const TestingDataEntry& from);

  inline TestingDataEntry& operator=(const TestingDataEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestingDataEntry& default_instance();

  void Swap(TestingDataEntry* other);

  // implements Message ----------------------------------------------

  TestingDataEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestingDataEntry& from);
  void MergeFrom(const TestingDataEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .encephal_alpha.DataType input_datatype = 1;
  inline bool has_input_datatype() const;
  inline void clear_input_datatype();
  static const int kInputDatatypeFieldNumber = 1;
  inline const ::encephal_alpha::DataType& input_datatype() const;
  inline ::encephal_alpha::DataType* mutable_input_datatype();
  inline ::encephal_alpha::DataType* release_input_datatype();
  inline void set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype);

  // required .encephal_alpha.DataArray entries = 2;
  inline bool has_entries() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::encephal_alpha::DataArray& entries() const;
  inline ::encephal_alpha::DataArray* mutable_entries();
  inline ::encephal_alpha::DataArray* release_entries();
  inline void set_allocated_entries(::encephal_alpha::DataArray* entries);

  // @@protoc_insertion_point(class_scope:encephal_alpha.TestingDataEntry)
 private:
  inline void set_has_input_datatype();
  inline void clear_has_input_datatype();
  inline void set_has_entries();
  inline void clear_has_entries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::DataType* input_datatype_;
  ::encephal_alpha::DataArray* entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static TestingDataEntry* default_instance_;
};
// -------------------------------------------------------------------

class DataEntry : public ::google::protobuf::Message {
 public:
  DataEntry();
  virtual ~DataEntry();

  DataEntry(const DataEntry& from);

  inline DataEntry& operator=(const DataEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataEntry& default_instance();

  void Swap(DataEntry* other);

  // implements Message ----------------------------------------------

  DataEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataEntry& from);
  void MergeFrom(const DataEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DataEntry_DataEntryType DataEntryType;
  static const DataEntryType TRAIN = DataEntry_DataEntryType_TRAIN;
  static const DataEntryType TEST = DataEntry_DataEntryType_TEST;
  static inline bool DataEntryType_IsValid(int value) {
    return DataEntry_DataEntryType_IsValid(value);
  }
  static const DataEntryType DataEntryType_MIN =
    DataEntry_DataEntryType_DataEntryType_MIN;
  static const DataEntryType DataEntryType_MAX =
    DataEntry_DataEntryType_DataEntryType_MAX;
  static const int DataEntryType_ARRAYSIZE =
    DataEntry_DataEntryType_DataEntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataEntryType_descriptor() {
    return DataEntry_DataEntryType_descriptor();
  }
  static inline const ::std::string& DataEntryType_Name(DataEntryType value) {
    return DataEntry_DataEntryType_Name(value);
  }
  static inline bool DataEntryType_Parse(const ::std::string& name,
      DataEntryType* value) {
    return DataEntry_DataEntryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .encephal_alpha.DataEntry.DataEntryType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::encephal_alpha::DataEntry_DataEntryType type() const;
  inline void set_type(::encephal_alpha::DataEntry_DataEntryType value);

  // optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
  inline bool has_traindataentry() const;
  inline void clear_traindataentry();
  static const int kTrainDataEntryFieldNumber = 2;
  inline const ::encephal_alpha::TrainingDataEntry& traindataentry() const;
  inline ::encephal_alpha::TrainingDataEntry* mutable_traindataentry();
  inline ::encephal_alpha::TrainingDataEntry* release_traindataentry();
  inline void set_allocated_traindataentry(::encephal_alpha::TrainingDataEntry* traindataentry);

  // optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
  inline bool has_testdataentry() const;
  inline void clear_testdataentry();
  static const int kTestDataEntryFieldNumber = 3;
  inline const ::encephal_alpha::TestingDataEntry& testdataentry() const;
  inline ::encephal_alpha::TestingDataEntry* mutable_testdataentry();
  inline ::encephal_alpha::TestingDataEntry* release_testdataentry();
  inline void set_allocated_testdataentry(::encephal_alpha::TestingDataEntry* testdataentry);

  // @@protoc_insertion_point(class_scope:encephal_alpha.DataEntry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_traindataentry();
  inline void clear_has_traindataentry();
  inline void set_has_testdataentry();
  inline void clear_has_testdataentry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::encephal_alpha::TrainingDataEntry* traindataentry_;
  ::encephal_alpha::TestingDataEntry* testdataentry_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_encephal_5falpha_2eproto();
  friend void protobuf_AssignDesc_encephal_5falpha_2eproto();
  friend void protobuf_ShutdownFile_encephal_5falpha_2eproto();

  void InitAsDefaultInstance();
  static DataEntry* default_instance_;
};
// ===================================================================


// ===================================================================

// DataType

// repeated uint32 dimensions = 1;
inline int DataType::dimensions_size() const {
  return dimensions_.size();
}
inline void DataType::clear_dimensions() {
  dimensions_.Clear();
}
inline ::google::protobuf::uint32 DataType::dimensions(int index) const {
  return dimensions_.Get(index);
}
inline void DataType::set_dimensions(int index, ::google::protobuf::uint32 value) {
  dimensions_.Set(index, value);
}
inline void DataType::add_dimensions(::google::protobuf::uint32 value) {
  dimensions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DataType::dimensions() const {
  return dimensions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DataType::mutable_dimensions() {
  return &dimensions_;
}

// required .encephal_alpha.DataType.NumericType type = 2;
inline bool DataType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataType::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataType::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataType::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::encephal_alpha::DataType_NumericType DataType::type() const {
  return static_cast< ::encephal_alpha::DataType_NumericType >(type_);
}
inline void DataType::set_type(::encephal_alpha::DataType_NumericType value) {
  assert(::encephal_alpha::DataType_NumericType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PerceptronLayerData

// required .encephal_alpha.ActivationFunction activation_function = 1;
inline bool PerceptronLayerData::has_activation_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceptronLayerData::set_has_activation_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceptronLayerData::clear_has_activation_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerceptronLayerData::clear_activation_function() {
  activation_function_ = 1;
  clear_has_activation_function();
}
inline ::encephal_alpha::ActivationFunction PerceptronLayerData::activation_function() const {
  return static_cast< ::encephal_alpha::ActivationFunction >(activation_function_);
}
inline void PerceptronLayerData::set_activation_function(::encephal_alpha::ActivationFunction value) {
  assert(::encephal_alpha::ActivationFunction_IsValid(value));
  set_has_activation_function();
  activation_function_ = value;
}

// -------------------------------------------------------------------

// ConvolutionalLayerData

// required .encephal_alpha.ConvolutionalLayerData.ZeroPaddingType zero_padding = 1;
inline bool ConvolutionalLayerData::has_zero_padding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvolutionalLayerData::set_has_zero_padding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvolutionalLayerData::clear_has_zero_padding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvolutionalLayerData::clear_zero_padding() {
  zero_padding_ = 1;
  clear_has_zero_padding();
}
inline ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType ConvolutionalLayerData::zero_padding() const {
  return static_cast< ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType >(zero_padding_);
}
inline void ConvolutionalLayerData::set_zero_padding(::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType value) {
  assert(::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType_IsValid(value));
  set_has_zero_padding();
  zero_padding_ = value;
}

// repeated uint32 kernel_shape = 2;
inline int ConvolutionalLayerData::kernel_shape_size() const {
  return kernel_shape_.size();
}
inline void ConvolutionalLayerData::clear_kernel_shape() {
  kernel_shape_.Clear();
}
inline ::google::protobuf::uint32 ConvolutionalLayerData::kernel_shape(int index) const {
  return kernel_shape_.Get(index);
}
inline void ConvolutionalLayerData::set_kernel_shape(int index, ::google::protobuf::uint32 value) {
  kernel_shape_.Set(index, value);
}
inline void ConvolutionalLayerData::add_kernel_shape(::google::protobuf::uint32 value) {
  kernel_shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ConvolutionalLayerData::kernel_shape() const {
  return kernel_shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ConvolutionalLayerData::mutable_kernel_shape() {
  return &kernel_shape_;
}

// -------------------------------------------------------------------

// DropoutLayerData

// required float p = 1;
inline bool DropoutLayerData::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropoutLayerData::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropoutLayerData::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropoutLayerData::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float DropoutLayerData::p() const {
  return p_;
}
inline void DropoutLayerData::set_p(float value) {
  set_has_p();
  p_ = value;
}

// -------------------------------------------------------------------

// FullConnexionLayerData

// -------------------------------------------------------------------

// PipeNode_PipeNodeData

// optional .encephal_alpha.FullConnexionLayerData full_connexion = 1;
inline bool PipeNode_PipeNodeData::has_full_connexion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipeNode_PipeNodeData::set_has_full_connexion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PipeNode_PipeNodeData::clear_has_full_connexion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PipeNode_PipeNodeData::clear_full_connexion() {
  if (full_connexion_ != NULL) full_connexion_->::encephal_alpha::FullConnexionLayerData::Clear();
  clear_has_full_connexion();
}
inline const ::encephal_alpha::FullConnexionLayerData& PipeNode_PipeNodeData::full_connexion() const {
  return full_connexion_ != NULL ? *full_connexion_ : *default_instance_->full_connexion_;
}
inline ::encephal_alpha::FullConnexionLayerData* PipeNode_PipeNodeData::mutable_full_connexion() {
  set_has_full_connexion();
  if (full_connexion_ == NULL) full_connexion_ = new ::encephal_alpha::FullConnexionLayerData;
  return full_connexion_;
}
inline ::encephal_alpha::FullConnexionLayerData* PipeNode_PipeNodeData::release_full_connexion() {
  clear_has_full_connexion();
  ::encephal_alpha::FullConnexionLayerData* temp = full_connexion_;
  full_connexion_ = NULL;
  return temp;
}
inline void PipeNode_PipeNodeData::set_allocated_full_connexion(::encephal_alpha::FullConnexionLayerData* full_connexion) {
  delete full_connexion_;
  full_connexion_ = full_connexion;
  if (full_connexion) {
    set_has_full_connexion();
  } else {
    clear_has_full_connexion();
  }
}

// optional .encephal_alpha.DropoutLayerData dropout_layer = 2;
inline bool PipeNode_PipeNodeData::has_dropout_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PipeNode_PipeNodeData::set_has_dropout_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PipeNode_PipeNodeData::clear_has_dropout_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PipeNode_PipeNodeData::clear_dropout_layer() {
  if (dropout_layer_ != NULL) dropout_layer_->::encephal_alpha::DropoutLayerData::Clear();
  clear_has_dropout_layer();
}
inline const ::encephal_alpha::DropoutLayerData& PipeNode_PipeNodeData::dropout_layer() const {
  return dropout_layer_ != NULL ? *dropout_layer_ : *default_instance_->dropout_layer_;
}
inline ::encephal_alpha::DropoutLayerData* PipeNode_PipeNodeData::mutable_dropout_layer() {
  set_has_dropout_layer();
  if (dropout_layer_ == NULL) dropout_layer_ = new ::encephal_alpha::DropoutLayerData;
  return dropout_layer_;
}
inline ::encephal_alpha::DropoutLayerData* PipeNode_PipeNodeData::release_dropout_layer() {
  clear_has_dropout_layer();
  ::encephal_alpha::DropoutLayerData* temp = dropout_layer_;
  dropout_layer_ = NULL;
  return temp;
}
inline void PipeNode_PipeNodeData::set_allocated_dropout_layer(::encephal_alpha::DropoutLayerData* dropout_layer) {
  delete dropout_layer_;
  dropout_layer_ = dropout_layer;
  if (dropout_layer) {
    set_has_dropout_layer();
  } else {
    clear_has_dropout_layer();
  }
}

// optional .encephal_alpha.PerceptronLayerData perceptron_layer = 3;
inline bool PipeNode_PipeNodeData::has_perceptron_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PipeNode_PipeNodeData::set_has_perceptron_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PipeNode_PipeNodeData::clear_has_perceptron_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PipeNode_PipeNodeData::clear_perceptron_layer() {
  if (perceptron_layer_ != NULL) perceptron_layer_->::encephal_alpha::PerceptronLayerData::Clear();
  clear_has_perceptron_layer();
}
inline const ::encephal_alpha::PerceptronLayerData& PipeNode_PipeNodeData::perceptron_layer() const {
  return perceptron_layer_ != NULL ? *perceptron_layer_ : *default_instance_->perceptron_layer_;
}
inline ::encephal_alpha::PerceptronLayerData* PipeNode_PipeNodeData::mutable_perceptron_layer() {
  set_has_perceptron_layer();
  if (perceptron_layer_ == NULL) perceptron_layer_ = new ::encephal_alpha::PerceptronLayerData;
  return perceptron_layer_;
}
inline ::encephal_alpha::PerceptronLayerData* PipeNode_PipeNodeData::release_perceptron_layer() {
  clear_has_perceptron_layer();
  ::encephal_alpha::PerceptronLayerData* temp = perceptron_layer_;
  perceptron_layer_ = NULL;
  return temp;
}
inline void PipeNode_PipeNodeData::set_allocated_perceptron_layer(::encephal_alpha::PerceptronLayerData* perceptron_layer) {
  delete perceptron_layer_;
  perceptron_layer_ = perceptron_layer;
  if (perceptron_layer) {
    set_has_perceptron_layer();
  } else {
    clear_has_perceptron_layer();
  }
}

// optional .encephal_alpha.ConvolutionalLayerData convolutional_layer = 4;
inline bool PipeNode_PipeNodeData::has_convolutional_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PipeNode_PipeNodeData::set_has_convolutional_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PipeNode_PipeNodeData::clear_has_convolutional_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PipeNode_PipeNodeData::clear_convolutional_layer() {
  if (convolutional_layer_ != NULL) convolutional_layer_->::encephal_alpha::ConvolutionalLayerData::Clear();
  clear_has_convolutional_layer();
}
inline const ::encephal_alpha::ConvolutionalLayerData& PipeNode_PipeNodeData::convolutional_layer() const {
  return convolutional_layer_ != NULL ? *convolutional_layer_ : *default_instance_->convolutional_layer_;
}
inline ::encephal_alpha::ConvolutionalLayerData* PipeNode_PipeNodeData::mutable_convolutional_layer() {
  set_has_convolutional_layer();
  if (convolutional_layer_ == NULL) convolutional_layer_ = new ::encephal_alpha::ConvolutionalLayerData;
  return convolutional_layer_;
}
inline ::encephal_alpha::ConvolutionalLayerData* PipeNode_PipeNodeData::release_convolutional_layer() {
  clear_has_convolutional_layer();
  ::encephal_alpha::ConvolutionalLayerData* temp = convolutional_layer_;
  convolutional_layer_ = NULL;
  return temp;
}
inline void PipeNode_PipeNodeData::set_allocated_convolutional_layer(::encephal_alpha::ConvolutionalLayerData* convolutional_layer) {
  delete convolutional_layer_;
  convolutional_layer_ = convolutional_layer;
  if (convolutional_layer) {
    set_has_convolutional_layer();
  } else {
    clear_has_convolutional_layer();
  }
}

// -------------------------------------------------------------------

// PipeNode

// required uint32 index = 1;
inline bool PipeNode::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipeNode::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PipeNode::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PipeNode::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PipeNode::index() const {
  return index_;
}
inline void PipeNode::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required .encephal_alpha.DataType input_datatype = 2;
inline bool PipeNode::has_input_datatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PipeNode::set_has_input_datatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PipeNode::clear_has_input_datatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PipeNode::clear_input_datatype() {
  if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
  clear_has_input_datatype();
}
inline const ::encephal_alpha::DataType& PipeNode::input_datatype() const {
  return input_datatype_ != NULL ? *input_datatype_ : *default_instance_->input_datatype_;
}
inline ::encephal_alpha::DataType* PipeNode::mutable_input_datatype() {
  set_has_input_datatype();
  if (input_datatype_ == NULL) input_datatype_ = new ::encephal_alpha::DataType;
  return input_datatype_;
}
inline ::encephal_alpha::DataType* PipeNode::release_input_datatype() {
  clear_has_input_datatype();
  ::encephal_alpha::DataType* temp = input_datatype_;
  input_datatype_ = NULL;
  return temp;
}
inline void PipeNode::set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype) {
  delete input_datatype_;
  input_datatype_ = input_datatype;
  if (input_datatype) {
    set_has_input_datatype();
  } else {
    clear_has_input_datatype();
  }
}

// required .encephal_alpha.DataType output_datatype = 3;
inline bool PipeNode::has_output_datatype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PipeNode::set_has_output_datatype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PipeNode::clear_has_output_datatype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PipeNode::clear_output_datatype() {
  if (output_datatype_ != NULL) output_datatype_->::encephal_alpha::DataType::Clear();
  clear_has_output_datatype();
}
inline const ::encephal_alpha::DataType& PipeNode::output_datatype() const {
  return output_datatype_ != NULL ? *output_datatype_ : *default_instance_->output_datatype_;
}
inline ::encephal_alpha::DataType* PipeNode::mutable_output_datatype() {
  set_has_output_datatype();
  if (output_datatype_ == NULL) output_datatype_ = new ::encephal_alpha::DataType;
  return output_datatype_;
}
inline ::encephal_alpha::DataType* PipeNode::release_output_datatype() {
  clear_has_output_datatype();
  ::encephal_alpha::DataType* temp = output_datatype_;
  output_datatype_ = NULL;
  return temp;
}
inline void PipeNode::set_allocated_output_datatype(::encephal_alpha::DataType* output_datatype) {
  delete output_datatype_;
  output_datatype_ = output_datatype;
  if (output_datatype) {
    set_has_output_datatype();
  } else {
    clear_has_output_datatype();
  }
}

// required uint32 input_socket_index = 4;
inline bool PipeNode::has_input_socket_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PipeNode::set_has_input_socket_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PipeNode::clear_has_input_socket_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PipeNode::clear_input_socket_index() {
  input_socket_index_ = 0u;
  clear_has_input_socket_index();
}
inline ::google::protobuf::uint32 PipeNode::input_socket_index() const {
  return input_socket_index_;
}
inline void PipeNode::set_input_socket_index(::google::protobuf::uint32 value) {
  set_has_input_socket_index();
  input_socket_index_ = value;
}

// required uint32 output_socket_index = 5;
inline bool PipeNode::has_output_socket_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PipeNode::set_has_output_socket_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PipeNode::clear_has_output_socket_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PipeNode::clear_output_socket_index() {
  output_socket_index_ = 0u;
  clear_has_output_socket_index();
}
inline ::google::protobuf::uint32 PipeNode::output_socket_index() const {
  return output_socket_index_;
}
inline void PipeNode::set_output_socket_index(::google::protobuf::uint32 value) {
  set_has_output_socket_index();
  output_socket_index_ = value;
}

// required .encephal_alpha.PipeNode.PipeNodeType node_type = 6;
inline bool PipeNode::has_node_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PipeNode::set_has_node_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PipeNode::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PipeNode::clear_node_type() {
  node_type_ = 1;
  clear_has_node_type();
}
inline ::encephal_alpha::PipeNode_PipeNodeType PipeNode::node_type() const {
  return static_cast< ::encephal_alpha::PipeNode_PipeNodeType >(node_type_);
}
inline void PipeNode::set_node_type(::encephal_alpha::PipeNode_PipeNodeType value) {
  assert(::encephal_alpha::PipeNode_PipeNodeType_IsValid(value));
  set_has_node_type();
  node_type_ = value;
}

// required .encephal_alpha.PipeNode.PipeNodeData data = 7;
inline bool PipeNode::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PipeNode::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PipeNode::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PipeNode::clear_data() {
  if (data_ != NULL) data_->::encephal_alpha::PipeNode_PipeNodeData::Clear();
  clear_has_data();
}
inline const ::encephal_alpha::PipeNode_PipeNodeData& PipeNode::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::encephal_alpha::PipeNode_PipeNodeData* PipeNode::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::encephal_alpha::PipeNode_PipeNodeData;
  return data_;
}
inline ::encephal_alpha::PipeNode_PipeNodeData* PipeNode::release_data() {
  clear_has_data();
  ::encephal_alpha::PipeNode_PipeNodeData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void PipeNode::set_allocated_data(::encephal_alpha::PipeNode_PipeNodeData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// Connection

// required uint32 socket_index = 1;
inline bool Connection::has_socket_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connection::set_has_socket_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connection::clear_has_socket_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connection::clear_socket_index() {
  socket_index_ = 0u;
  clear_has_socket_index();
}
inline ::google::protobuf::uint32 Connection::socket_index() const {
  return socket_index_;
}
inline void Connection::set_socket_index(::google::protobuf::uint32 value) {
  set_has_socket_index();
  socket_index_ = value;
}

// required uint32 node_index = 2;
inline bool Connection::has_node_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connection::set_has_node_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connection::clear_has_node_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connection::clear_node_index() {
  node_index_ = 0u;
  clear_has_node_index();
}
inline ::google::protobuf::uint32 Connection::node_index() const {
  return node_index_;
}
inline void Connection::set_node_index(::google::protobuf::uint32 value) {
  set_has_node_index();
  node_index_ = value;
}

// -------------------------------------------------------------------

// Socket

// required uint32 index = 1;
inline bool Socket::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Socket::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Socket::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Socket::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Socket::index() const {
  return index_;
}
inline void Socket::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required .encephal_alpha.DataType datatype = 2;
inline bool Socket::has_datatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Socket::set_has_datatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Socket::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Socket::clear_datatype() {
  if (datatype_ != NULL) datatype_->::encephal_alpha::DataType::Clear();
  clear_has_datatype();
}
inline const ::encephal_alpha::DataType& Socket::datatype() const {
  return datatype_ != NULL ? *datatype_ : *default_instance_->datatype_;
}
inline ::encephal_alpha::DataType* Socket::mutable_datatype() {
  set_has_datatype();
  if (datatype_ == NULL) datatype_ = new ::encephal_alpha::DataType;
  return datatype_;
}
inline ::encephal_alpha::DataType* Socket::release_datatype() {
  clear_has_datatype();
  ::encephal_alpha::DataType* temp = datatype_;
  datatype_ = NULL;
  return temp;
}
inline void Socket::set_allocated_datatype(::encephal_alpha::DataType* datatype) {
  delete datatype_;
  datatype_ = datatype;
  if (datatype) {
    set_has_datatype();
  } else {
    clear_has_datatype();
  }
}

// -------------------------------------------------------------------

// SchedulerNodeLayer

// repeated .encephal_alpha.PipeNode nodes = 1;
inline int SchedulerNodeLayer::nodes_size() const {
  return nodes_.size();
}
inline void SchedulerNodeLayer::clear_nodes() {
  nodes_.Clear();
}
inline const ::encephal_alpha::PipeNode& SchedulerNodeLayer::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::encephal_alpha::PipeNode* SchedulerNodeLayer::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::encephal_alpha::PipeNode* SchedulerNodeLayer::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::PipeNode >&
SchedulerNodeLayer::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::PipeNode >*
SchedulerNodeLayer::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// Graph

// repeated .encephal_alpha.SchedulerNodeLayer node_layers = 1;
inline int Graph::node_layers_size() const {
  return node_layers_.size();
}
inline void Graph::clear_node_layers() {
  node_layers_.Clear();
}
inline const ::encephal_alpha::SchedulerNodeLayer& Graph::node_layers(int index) const {
  return node_layers_.Get(index);
}
inline ::encephal_alpha::SchedulerNodeLayer* Graph::mutable_node_layers(int index) {
  return node_layers_.Mutable(index);
}
inline ::encephal_alpha::SchedulerNodeLayer* Graph::add_node_layers() {
  return node_layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::SchedulerNodeLayer >&
Graph::node_layers() const {
  return node_layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::SchedulerNodeLayer >*
Graph::mutable_node_layers() {
  return &node_layers_;
}

// repeated .encephal_alpha.Socket sockets = 2;
inline int Graph::sockets_size() const {
  return sockets_.size();
}
inline void Graph::clear_sockets() {
  sockets_.Clear();
}
inline const ::encephal_alpha::Socket& Graph::sockets(int index) const {
  return sockets_.Get(index);
}
inline ::encephal_alpha::Socket* Graph::mutable_sockets(int index) {
  return sockets_.Mutable(index);
}
inline ::encephal_alpha::Socket* Graph::add_sockets() {
  return sockets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::encephal_alpha::Socket >&
Graph::sockets() const {
  return sockets_;
}
inline ::google::protobuf::RepeatedPtrField< ::encephal_alpha::Socket >*
Graph::mutable_sockets() {
  return &sockets_;
}

// required uint32 entry_socket = 3;
inline bool Graph::has_entry_socket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Graph::set_has_entry_socket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Graph::clear_has_entry_socket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Graph::clear_entry_socket() {
  entry_socket_ = 0u;
  clear_has_entry_socket();
}
inline ::google::protobuf::uint32 Graph::entry_socket() const {
  return entry_socket_;
}
inline void Graph::set_entry_socket(::google::protobuf::uint32 value) {
  set_has_entry_socket();
  entry_socket_ = value;
}

// required uint32 exit_socket = 4;
inline bool Graph::has_exit_socket() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Graph::set_has_exit_socket() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Graph::clear_has_exit_socket() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Graph::clear_exit_socket() {
  exit_socket_ = 0u;
  clear_has_exit_socket();
}
inline ::google::protobuf::uint32 Graph::exit_socket() const {
  return exit_socket_;
}
inline void Graph::set_exit_socket(::google::protobuf::uint32 value) {
  set_has_exit_socket();
  exit_socket_ = value;
}

// -------------------------------------------------------------------

// DataArray

// repeated float float_vector = 1;
inline int DataArray::float_vector_size() const {
  return float_vector_.size();
}
inline void DataArray::clear_float_vector() {
  float_vector_.Clear();
}
inline float DataArray::float_vector(int index) const {
  return float_vector_.Get(index);
}
inline void DataArray::set_float_vector(int index, float value) {
  float_vector_.Set(index, value);
}
inline void DataArray::add_float_vector(float value) {
  float_vector_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DataArray::float_vector() const {
  return float_vector_;
}
inline ::google::protobuf::RepeatedField< float >*
DataArray::mutable_float_vector() {
  return &float_vector_;
}

// repeated uint32 uint32_vector = 2;
inline int DataArray::uint32_vector_size() const {
  return uint32_vector_.size();
}
inline void DataArray::clear_uint32_vector() {
  uint32_vector_.Clear();
}
inline ::google::protobuf::uint32 DataArray::uint32_vector(int index) const {
  return uint32_vector_.Get(index);
}
inline void DataArray::set_uint32_vector(int index, ::google::protobuf::uint32 value) {
  uint32_vector_.Set(index, value);
}
inline void DataArray::add_uint32_vector(::google::protobuf::uint32 value) {
  uint32_vector_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DataArray::uint32_vector() const {
  return uint32_vector_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DataArray::mutable_uint32_vector() {
  return &uint32_vector_;
}

// repeated uint64 uint64_vector = 3;
inline int DataArray::uint64_vector_size() const {
  return uint64_vector_.size();
}
inline void DataArray::clear_uint64_vector() {
  uint64_vector_.Clear();
}
inline ::google::protobuf::uint64 DataArray::uint64_vector(int index) const {
  return uint64_vector_.Get(index);
}
inline void DataArray::set_uint64_vector(int index, ::google::protobuf::uint64 value) {
  uint64_vector_.Set(index, value);
}
inline void DataArray::add_uint64_vector(::google::protobuf::uint64 value) {
  uint64_vector_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DataArray::uint64_vector() const {
  return uint64_vector_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DataArray::mutable_uint64_vector() {
  return &uint64_vector_;
}

// repeated bool bool_vector = 4;
inline int DataArray::bool_vector_size() const {
  return bool_vector_.size();
}
inline void DataArray::clear_bool_vector() {
  bool_vector_.Clear();
}
inline bool DataArray::bool_vector(int index) const {
  return bool_vector_.Get(index);
}
inline void DataArray::set_bool_vector(int index, bool value) {
  bool_vector_.Set(index, value);
}
inline void DataArray::add_bool_vector(bool value) {
  bool_vector_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
DataArray::bool_vector() const {
  return bool_vector_;
}
inline ::google::protobuf::RepeatedField< bool >*
DataArray::mutable_bool_vector() {
  return &bool_vector_;
}

// -------------------------------------------------------------------

// TrainingDataEntry

// required .encephal_alpha.DataType input_datatype = 1;
inline bool TrainingDataEntry::has_input_datatype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainingDataEntry::set_has_input_datatype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainingDataEntry::clear_has_input_datatype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainingDataEntry::clear_input_datatype() {
  if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
  clear_has_input_datatype();
}
inline const ::encephal_alpha::DataType& TrainingDataEntry::input_datatype() const {
  return input_datatype_ != NULL ? *input_datatype_ : *default_instance_->input_datatype_;
}
inline ::encephal_alpha::DataType* TrainingDataEntry::mutable_input_datatype() {
  set_has_input_datatype();
  if (input_datatype_ == NULL) input_datatype_ = new ::encephal_alpha::DataType;
  return input_datatype_;
}
inline ::encephal_alpha::DataType* TrainingDataEntry::release_input_datatype() {
  clear_has_input_datatype();
  ::encephal_alpha::DataType* temp = input_datatype_;
  input_datatype_ = NULL;
  return temp;
}
inline void TrainingDataEntry::set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype) {
  delete input_datatype_;
  input_datatype_ = input_datatype;
  if (input_datatype) {
    set_has_input_datatype();
  } else {
    clear_has_input_datatype();
  }
}

// required .encephal_alpha.DataType output_datatype = 2;
inline bool TrainingDataEntry::has_output_datatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainingDataEntry::set_has_output_datatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainingDataEntry::clear_has_output_datatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainingDataEntry::clear_output_datatype() {
  if (output_datatype_ != NULL) output_datatype_->::encephal_alpha::DataType::Clear();
  clear_has_output_datatype();
}
inline const ::encephal_alpha::DataType& TrainingDataEntry::output_datatype() const {
  return output_datatype_ != NULL ? *output_datatype_ : *default_instance_->output_datatype_;
}
inline ::encephal_alpha::DataType* TrainingDataEntry::mutable_output_datatype() {
  set_has_output_datatype();
  if (output_datatype_ == NULL) output_datatype_ = new ::encephal_alpha::DataType;
  return output_datatype_;
}
inline ::encephal_alpha::DataType* TrainingDataEntry::release_output_datatype() {
  clear_has_output_datatype();
  ::encephal_alpha::DataType* temp = output_datatype_;
  output_datatype_ = NULL;
  return temp;
}
inline void TrainingDataEntry::set_allocated_output_datatype(::encephal_alpha::DataType* output_datatype) {
  delete output_datatype_;
  output_datatype_ = output_datatype;
  if (output_datatype) {
    set_has_output_datatype();
  } else {
    clear_has_output_datatype();
  }
}

// required .encephal_alpha.DataArray input = 3;
inline bool TrainingDataEntry::has_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainingDataEntry::set_has_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainingDataEntry::clear_has_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainingDataEntry::clear_input() {
  if (input_ != NULL) input_->::encephal_alpha::DataArray::Clear();
  clear_has_input();
}
inline const ::encephal_alpha::DataArray& TrainingDataEntry::input() const {
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::encephal_alpha::DataArray* TrainingDataEntry::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::encephal_alpha::DataArray;
  return input_;
}
inline ::encephal_alpha::DataArray* TrainingDataEntry::release_input() {
  clear_has_input();
  ::encephal_alpha::DataArray* temp = input_;
  input_ = NULL;
  return temp;
}
inline void TrainingDataEntry::set_allocated_input(::encephal_alpha::DataArray* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// required .encephal_alpha.DataArray label = 4;
inline bool TrainingDataEntry::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrainingDataEntry::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrainingDataEntry::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrainingDataEntry::clear_label() {
  if (label_ != NULL) label_->::encephal_alpha::DataArray::Clear();
  clear_has_label();
}
inline const ::encephal_alpha::DataArray& TrainingDataEntry::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::encephal_alpha::DataArray* TrainingDataEntry::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::encephal_alpha::DataArray;
  return label_;
}
inline ::encephal_alpha::DataArray* TrainingDataEntry::release_label() {
  clear_has_label();
  ::encephal_alpha::DataArray* temp = label_;
  label_ = NULL;
  return temp;
}
inline void TrainingDataEntry::set_allocated_label(::encephal_alpha::DataArray* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// -------------------------------------------------------------------

// TestingDataEntry

// required .encephal_alpha.DataType input_datatype = 1;
inline bool TestingDataEntry::has_input_datatype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestingDataEntry::set_has_input_datatype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestingDataEntry::clear_has_input_datatype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestingDataEntry::clear_input_datatype() {
  if (input_datatype_ != NULL) input_datatype_->::encephal_alpha::DataType::Clear();
  clear_has_input_datatype();
}
inline const ::encephal_alpha::DataType& TestingDataEntry::input_datatype() const {
  return input_datatype_ != NULL ? *input_datatype_ : *default_instance_->input_datatype_;
}
inline ::encephal_alpha::DataType* TestingDataEntry::mutable_input_datatype() {
  set_has_input_datatype();
  if (input_datatype_ == NULL) input_datatype_ = new ::encephal_alpha::DataType;
  return input_datatype_;
}
inline ::encephal_alpha::DataType* TestingDataEntry::release_input_datatype() {
  clear_has_input_datatype();
  ::encephal_alpha::DataType* temp = input_datatype_;
  input_datatype_ = NULL;
  return temp;
}
inline void TestingDataEntry::set_allocated_input_datatype(::encephal_alpha::DataType* input_datatype) {
  delete input_datatype_;
  input_datatype_ = input_datatype;
  if (input_datatype) {
    set_has_input_datatype();
  } else {
    clear_has_input_datatype();
  }
}

// required .encephal_alpha.DataArray entries = 2;
inline bool TestingDataEntry::has_entries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestingDataEntry::set_has_entries() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestingDataEntry::clear_has_entries() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestingDataEntry::clear_entries() {
  if (entries_ != NULL) entries_->::encephal_alpha::DataArray::Clear();
  clear_has_entries();
}
inline const ::encephal_alpha::DataArray& TestingDataEntry::entries() const {
  return entries_ != NULL ? *entries_ : *default_instance_->entries_;
}
inline ::encephal_alpha::DataArray* TestingDataEntry::mutable_entries() {
  set_has_entries();
  if (entries_ == NULL) entries_ = new ::encephal_alpha::DataArray;
  return entries_;
}
inline ::encephal_alpha::DataArray* TestingDataEntry::release_entries() {
  clear_has_entries();
  ::encephal_alpha::DataArray* temp = entries_;
  entries_ = NULL;
  return temp;
}
inline void TestingDataEntry::set_allocated_entries(::encephal_alpha::DataArray* entries) {
  delete entries_;
  entries_ = entries;
  if (entries) {
    set_has_entries();
  } else {
    clear_has_entries();
  }
}

// -------------------------------------------------------------------

// DataEntry

// required .encephal_alpha.DataEntry.DataEntryType type = 1;
inline bool DataEntry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataEntry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataEntry::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::encephal_alpha::DataEntry_DataEntryType DataEntry::type() const {
  return static_cast< ::encephal_alpha::DataEntry_DataEntryType >(type_);
}
inline void DataEntry::set_type(::encephal_alpha::DataEntry_DataEntryType value) {
  assert(::encephal_alpha::DataEntry_DataEntryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .encephal_alpha.TrainingDataEntry trainDataEntry = 2;
inline bool DataEntry::has_traindataentry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataEntry::set_has_traindataentry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataEntry::clear_has_traindataentry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataEntry::clear_traindataentry() {
  if (traindataentry_ != NULL) traindataentry_->::encephal_alpha::TrainingDataEntry::Clear();
  clear_has_traindataentry();
}
inline const ::encephal_alpha::TrainingDataEntry& DataEntry::traindataentry() const {
  return traindataentry_ != NULL ? *traindataentry_ : *default_instance_->traindataentry_;
}
inline ::encephal_alpha::TrainingDataEntry* DataEntry::mutable_traindataentry() {
  set_has_traindataentry();
  if (traindataentry_ == NULL) traindataentry_ = new ::encephal_alpha::TrainingDataEntry;
  return traindataentry_;
}
inline ::encephal_alpha::TrainingDataEntry* DataEntry::release_traindataentry() {
  clear_has_traindataentry();
  ::encephal_alpha::TrainingDataEntry* temp = traindataentry_;
  traindataentry_ = NULL;
  return temp;
}
inline void DataEntry::set_allocated_traindataentry(::encephal_alpha::TrainingDataEntry* traindataentry) {
  delete traindataentry_;
  traindataentry_ = traindataentry;
  if (traindataentry) {
    set_has_traindataentry();
  } else {
    clear_has_traindataentry();
  }
}

// optional .encephal_alpha.TestingDataEntry testDataEntry = 3;
inline bool DataEntry::has_testdataentry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataEntry::set_has_testdataentry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataEntry::clear_has_testdataentry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataEntry::clear_testdataentry() {
  if (testdataentry_ != NULL) testdataentry_->::encephal_alpha::TestingDataEntry::Clear();
  clear_has_testdataentry();
}
inline const ::encephal_alpha::TestingDataEntry& DataEntry::testdataentry() const {
  return testdataentry_ != NULL ? *testdataentry_ : *default_instance_->testdataentry_;
}
inline ::encephal_alpha::TestingDataEntry* DataEntry::mutable_testdataentry() {
  set_has_testdataentry();
  if (testdataentry_ == NULL) testdataentry_ = new ::encephal_alpha::TestingDataEntry;
  return testdataentry_;
}
inline ::encephal_alpha::TestingDataEntry* DataEntry::release_testdataentry() {
  clear_has_testdataentry();
  ::encephal_alpha::TestingDataEntry* temp = testdataentry_;
  testdataentry_ = NULL;
  return temp;
}
inline void DataEntry::set_allocated_testdataentry(::encephal_alpha::TestingDataEntry* testdataentry) {
  delete testdataentry_;
  testdataentry_ = testdataentry;
  if (testdataentry) {
    set_has_testdataentry();
  } else {
    clear_has_testdataentry();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace encephal_alpha

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::encephal_alpha::DataType_NumericType>() {
  return ::encephal_alpha::DataType_NumericType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType>() {
  return ::encephal_alpha::ConvolutionalLayerData_ZeroPaddingType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::encephal_alpha::PipeNode_PipeNodeType>() {
  return ::encephal_alpha::PipeNode_PipeNodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::encephal_alpha::DataEntry_DataEntryType>() {
  return ::encephal_alpha::DataEntry_DataEntryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::encephal_alpha::ActivationFunction>() {
  return ::encephal_alpha::ActivationFunction_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_encephal_5falpha_2eproto__INCLUDED
